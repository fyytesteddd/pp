local success, Chloex = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/albibot69-lgtm/ui/refs/heads/main/LexsUiC.lua"))()
end)

-- [[ load Window ]]
local Window = Chloex:Window({
    Title   = "Lexs Hub | Premium | ",                --- title
    Footer  = "V0.0.9.6",                   --- in right after title
    Image   = "103875081318049",           ---- rbxassetid (texture)
    Color   = Color3.fromRGB(0, 221, 255), --- colour text/ui
    Theme   = 9542022979,                  ---- background for theme ui (rbxassetid)
    Version = 1,                           --- version config set as default 1 if u remake / rewrite / big update and change name name in your hub change it to 2 and config will reset
})

--- [[ Notify ]]
if Window then
    Lexs("Window loaded!")
end

local Tabs = {
    Info = Window:AddTab({ Name = "Info", Icon = "player" }),
    Player = Window:AddTab({ Name = "Player", Icon = "user" }), --- rbxassetid / robloxassetid (decals - texture)
    Main = Window:AddTab({ Name = "Main", Icon = "gamepad" }),
    Auto = Window:AddTab({ Name = "Auto", Icon = "loop" }),
    Exc = Window:AddTab({ Name = "Exclusive", Icon = "lexshub" }),
    Shop = Window:AddTab({ Name = "Shop", Icon = "shop" }),
    Teleport = Window:AddTab({ Name = "Teleport", Icon = "compas" }),
    Event = Window:AddTab({ Name = "Event", Icon = "gps" }),
    Trade = Window:AddTab({ Name = "Trade", Icon = "bag" }),
    Ench = Window:AddTab({ Name = "Enchant", Icon = "web" }),
    Totem = Window:AddTab({ Name = "Totem", Icon = "stat" }),
    Quest = Window:AddTab({ Name = "Quest", Icon = "scroll" }),
    Settings = Window:AddTab({ Name = "Settings", Icon = "settings" }),
    Webhook = Window:AddTab({ Name = "Webhook", Icon = "discord" }),
}

v1 = Tabs.Info:AddSection("Discord", true)

v1:AddParagraph({
    Title = "Join Our Discord",
    Content = "Join Us!",
    Icon = "discord",
    ButtonText = "Copy Discord Link",
    ButtonCallback = function()
        local link = "https://discord.gg/lexshub"
        if setclipboard then
            setclipboard(link)
            Lexs("Successfully Copied!")
        end
    end
})

x1 = Tabs.Player:AddSection("Player")

local P = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")
_G.InfiniteJump = false

x1:AddToggle({
    Title = "Infinite Jump",
    Content = "Makes you jump without limits",
    Default = false,
    Callback = function(state)
        _G.InfiniteJump = state
    end
})

UIS.JumpRequest:Connect(function()
    if _G.InfiniteJump then
        local h = P.Character and P.Character:FindFirstChildOfClass("Humanoid")
        if h then
            h:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

local Player = game:GetService("Players").LocalPlayer

x1:AddToggle({
    Title = "Noclip",
    Content = "Walk through walls",
    Default = false,
    Callback = function(state)
        _G.Noclip = state
        if state then
            task.spawn(function()
                while _G.Noclip do
                    task.wait(0.1)
                    local character = Player.Character
                    if character then
                        for _, part in pairs(character:GetDescendants()) do
                            if part:IsA("BasePart") and part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    end
                end
            end)
        end
    end
})

local P, SG = game.Players.LocalPlayer, game.StarterGui
local frozen, last

local function msg(t,c)
	pcall(function()
		SG:SetCore("ChatMakeSystemMessage",{
			Text="[FREEZE] "..t,
			Color=c or Color3.fromRGB(150,255,150),
			Font=Enum.Font.SourceSansBold,
			FontSize=Enum.FontSize.Size24
		})
	end)
end

local function setFreeze(s)
	local c = P.Character or P.CharacterAdded:Wait()
	local h = c:FindFirstChildOfClass("Humanoid")
	local r = c:FindFirstChild("HumanoidRootPart")
	if not h or not r then return end

	if s then
		last = r.CFrame
		h.WalkSpeed,h.JumpPower,h.AutoRotate,h.PlatformStand = 0,0,false,true
		for _,t in ipairs(h:GetPlayingAnimationTracks()) do t:Stop(0) end
		local a = h:FindFirstChildOfClass("Animator")
		if a then a:Destroy() end
		r.Anchored = true
		msg("Freeze character",Color3.fromRGB(100,200,255))
	else
		h.WalkSpeed,h.JumpPower,h.AutoRotate,h.PlatformStand = 16,50,true,false
		if not h:FindFirstChildOfClass("Animator") then Instance.new("Animator",h) end
		r.Anchored = false
		if last then r.CFrame = last end
		msg("Character released",Color3.fromRGB(255,150,150))
	end
end

x1:AddToggle({
	Title = "Freeze Character",
	Default = false,
	Callback=function(s)
		frozen = s
		setFreeze(s)
	end
})

P.CharacterAdded:Connect(function(c)
	if frozen then task.wait(.5); setFreeze(true) end
end)

Players = game:GetService("Players")
Player = Players.LocalPlayer

_G.DisableAnimation = false

function getHumanoid()
    return (Player.Character or Player.CharacterAdded:Wait()):WaitForChild("Humanoid")
end

function stopAnimation()
    humanoid = getHumanoid()
    animator = humanoid:FindFirstChildOfClass("Animator")

    if animator then
        for _, v in pairs(animator:GetPlayingAnimationTracks()) do
            v:Stop()
        end
        animator.Enabled = false
    end
end

function enableAnimation()
    humanoid = getHumanoid()
    animator = humanoid:FindFirstChildOfClass("Animator")

    if animator then
        animator.Enabled = true
    end
end

x1:AddToggle({
    Title = "Disable Animation",
    Content = "Matikan semua animasi karakter.",
    Default = false,
    Callback = function(state)
        _G.DisableAnimation = state

        if state then
            stopAnimation()
        else
            enableAnimation()
        end
    end
})

Player.CharacterAdded:Connect(function()
    task.wait(0.3)
    if _G.DisableAnimation then
        stopAnimation()
    end
end)

---------

_G.LocalPlayer = game:GetService("Players").LocalPlayer
_G.RunService = game:GetService("RunService")
_G.UserInputService = game:GetService("UserInputService")

_G.walkOnWaterConnection = nil
_G.isWalkOnWater = false
_G.waterPlatform = nil

x1:AddToggle({
	Title = "Walk on Water",
	Default = false,
	Callback = function(state)
		if state then
			_G.isWalkOnWater = true

			if not _G.waterPlatform then
				_G.waterPlatform = Instance.new("Part")
				_G.waterPlatform.Name = "WaterPlatform"
				_G.waterPlatform.Anchored = true
				_G.waterPlatform.CanCollide = true
				_G.waterPlatform.Transparency = 1
				_G.waterPlatform.Size = Vector3.new(15, 1, 15)
				_G.waterPlatform.Parent = workspace
			end

			if _G.walkOnWaterConnection then
				_G.walkOnWaterConnection:Disconnect()
			end

			_G.walkOnWaterConnection = _G.RunService.RenderStepped:Connect(function()
				if not _G.isWalkOnWater then return end

				_G.character = _G.LocalPlayer.Character
				if not _G.character then return end

				_G.hrp = _G.character:FindFirstChild("HumanoidRootPart")
				if not _G.hrp then return end

				_G.rayParams = RaycastParams.new()
				_G.rayParams.FilterDescendantsInstances = { workspace.Terrain }
				_G.rayParams.FilterType = Enum.RaycastFilterType.Include
				_G.rayParams.IgnoreWater = false

				_G.result = workspace:Raycast(
					_G.hrp.Position + Vector3.new(0,5,0),
					Vector3.new(0,-500,0),
					_G.rayParams
				)

				if _G.result and _G.result.Material == Enum.Material.Water then
					_G.waterY = _G.result.Position.Y

					_G.waterPlatform.Position = Vector3.new(
						_G.hrp.Position.X,
						_G.waterY,
						_G.hrp.Position.Z
					)

					if _G.hrp.Position.Y < _G.waterY + 2 then
						if not _G.UserInputService:IsKeyDown(Enum.KeyCode.Space) then
							_G.hrp.CFrame = CFrame.new(
								_G.hrp.Position.X,
								_G.waterY + 3.2,
								_G.hrp.Position.Z
							)
						end
					end
				else
					_G.waterPlatform.Position = Vector3.new(
						_G.hrp.Position.X,
						-500,
						_G.hrp.Position.Z
					)
				end
			end)

		else
			_G.isWalkOnWater = false

			if _G.walkOnWaterConnection then
				_G.walkOnWaterConnection:Disconnect()
				_G.walkOnWaterConnection = nil
			end

			if _G.waterPlatform then
				_G.waterPlatform:Destroy()
				_G.waterPlatform = nil
			end
		end
	end
})

_G.AutoFishing = false
_G.AutoEquipRod = false
_G.Radar = false
_G.Instant = false
_G.InstantDelay = _G.InstantDelay or 0.35
_G.CallMinDelay = _G.CallMinDelay or 0.18
_G.CallBackoff = _G.CallBackoff or 1.5

lastCall = {}
function safeCall(k, f)
    n = os.clock()
    if lastCall[k] and n - lastCall[k] < _G.CallMinDelay then
        task.wait(_G.CallMinDelay - (n - lastCall[k]))
    end
    ok, result = pcall(f)
    lastCall[k] = os.clock()
    if not ok then
        msg = tostring(result):lower()
        task.wait((msg:find("429") or msg:find("too many requests")) and _G.CallBackoff or 0.2)
    end
    return ok, result
end

RS = game:GetService("ReplicatedStorage")
net = RS.Packages._Index["sleitnick_net@0.2.0"].net

function rod()
    safeCall("rod", function()
        net["RE/EquipToolFromHotbar"]:FireServer(1)
    end)
end

function autoon()
    safeCall("autoon", function()
        net["RF/UpdateAutoFishingState"]:InvokeServer(true)
    end)
end

function autooff()
    safeCall("autooff", function()
        net["RF/UpdateAutoFishingState"]:InvokeServer(false)
    end)
end

function catch()
    safeCall("catch", function()
        net["RE/FishingCompleted"]:FireServer()
    end)
end

function charge()
    safeCall("charge", function()
        net["RF/ChargeFishingRod"]:InvokeServer()
    end)
end

function lempar()
    safeCall("lempar", function()
        net["RF/RequestFishingMinigameStarted"]:InvokeServer(-139.63, 0.996, -1761532005.497)
    end)
    safeCall("charge2", function()
        net["RF/ChargeFishingRod"]:InvokeServer()
    end)
end

function instant_cycle()
    charge()
    lempar()
    task.wait(_G.InstantDelay)
    catch()
end

x2 = Tabs.Main:AddSection("Fishing")

mode = "Instant"
fishThread = nil

x2:AddDropdown({
    Title = "Fishing Mode",
    Options = {"Instant", "Legit"},
    Default = "Instant",
    Callback = function(value)
        mode = value
    end
})

x2:AddToggle({
    Title = "Auto Fishing",
    Default = false,
    Callback = function(state)
        _G.AutoFishing = state

        if state then
            if _G.AutoEquipRod then rod() end

            if mode == "Instant" then
                _G.Instant = true
                if fishThread then task.cancel(fishThread) end
                fishThread = task.spawn(function()
                    while _G.AutoFishing and mode == "Instant" do
                        instant_cycle()
                        task.wait(_G.InstantDelay or 0.35)
                    end
                end)
            else
                if fishThread then task.cancel(fishThread) end
                fishThread = task.spawn(function()
                    while _G.AutoFishing and mode == "Legit" do
                        autoon()
                        task.wait(1)
                    end
                end)
            end
        else
            autooff()
            _G.Instant = false
            if fishThread then task.cancel(fishThread) end
            fishThread = nil
        end
    end
})

x2:AddSlider({
    Title = "Fishing Delay",
    Min = 0.1,
    Max = 10,
    Increment = 1,
    Default = _G.InstantDelay or 0.35,
    Callback = function(value)
        _G.InstantDelay = value
    end
})

x3 = Tabs.Main:AddSection("Item")

_G.Radar = false

RS = game:GetService("ReplicatedStorage")
net = RS:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

function radarOn()
    net:WaitForChild("RF/UpdateFishingRadar"):InvokeServer(true)
end

function radarOff()
    net:WaitForChild("RF/UpdateFishingRadar"):InvokeServer(false)
end

x3:AddToggle({
    Title = "Fishing Radar",
    Default = false,
    Callback = function(state)
        _G.Radar = state

        if state then
            radarOn()
            Lexs("Fishing Radar On.")
        else
            radarOff()
        end
    end
})

x3:AddToggle({
    Title = "Auto Equip Diving Gear",
    Default = false,
    Callback = function(s)
        local net = game.ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net
        if s then
            net["RF/EquipOxygenTank"]:InvokeServer(105)
        else
            net["RF/UnequipOxygenTank"]:InvokeServer()
        end
    end
})

_G.AutoOxygen = false

_G.RS = game:GetService("ReplicatedStorage")
_G.Net = _G.RS.Packages._Index["sleitnick_net@0.2.0"].net

x3:AddToggle({
    Title = "Auto Equip Advanced Diving Gear",
    Default = false,
    Callback = function(v)
        _G.AutoOxygen = v
        pcall(function()
            if v then
                _G.Net["RF/EquipOxygenTank"]:InvokeServer(575)
            else
                _G.Net["RF/UnequipOxygenTank"]:InvokeServer()
            end
        end)
    end
})

x4 = Tabs.Auto:AddSection("Auto Favorite")

_G.FavSystem = _G.FavSystem or {}

_G.FavSystem = _G.FavSystem or {}

if not _G.FavSystem.Init then
    RS = game:GetService("ReplicatedStorage")
    net = RS.Packages._Index["sleitnick_net@0.2.0"].net

    _G.FavSystem.REF = net["RE/FavoriteItem"]
    _G.FavSystem.REN = net["RE/ObtainedNewFishNotification"]
    _G.FavSystem.Items = RS:FindFirstChild("Items")
    _G.FavSystem.Conn = nil
    _G.FavSystem.Tiers = {}
    _G.FavSystem.Muts = {}
    _G.FavSystem.Fish = {Common={},Uncommon={},Rare={},Epic={},Legendary={},Mythic={},SECRET={}}
    _G.FavSystem.Init = true
end

if not _G.FavSystem.Loaded then
    if _G.FavSystem.Items and _G.FavSystem.Items:IsA("ModuleScript") then
        ok, data = pcall(require, _G.FavSystem.Items)
        if ok and data then
            map = {[1]="Common",[2]="Uncommon",[3]="Rare",[4]="Epic",[5]="Legendary",[6]="Mythic",[7]="SECRET"}
            for _, d in pairs(data) do
                if type(d)=="table" and d.Data and d.Data.Type=="Fish" then
                    t = map[d.Data.Tier or 1] or "Common"
                    if _G.FavSystem.Fish[t] then
                        table.insert(_G.FavSystem.Fish[t], d.Data.Id)
                    end
                end
            end
            for _, v in pairs(_G.FavSystem.Fish) do table.sort(v) end
            _G.FavSystem.Loaded = true
        end
    end
end

function favFish(id, w, i)
    m = (w and w.VariantId) or (i and i.InventoryItem and i.InventoryItem.Metadata and i.InventoryItem.Metadata.VariantId)

    for _, t in pairs(_G.FavSystem.Tiers) do
        if _G.FavSystem.Fish[t] and table.find(_G.FavSystem.Fish[t], id) then
            u = i and i.InventoryItem and i.InventoryItem.UUID or id
            task.spawn(function() pcall(function() _G.FavSystem.REF:FireServer(u) end) end)
            return
        end
    end

    if m and table.find(_G.FavSystem.Muts, m) then
        u = i and i.InventoryItem and i.InventoryItem.UUID or id
        task.spawn(function() pcall(function() _G.FavSystem.REF:FireServer(u) end) end)
    end
end

rar = {"Common","Uncommon","Rare","Epic","Legendary","Mythic","SECRET"}
muts = {"Shiny","Albino","Sandy","Noob","Moon Fragment","Festive","Disco","1x1x1x1","Bloodmoon","Color Burn","Corrupt","Fairy Dust","Frozen","Galaxy","Gemstone","Ghost","Gold","Holographic","Lightning","Midnight","Radioactive","Stone","Leviathan's Rage"}

x4:AddDropdown({
    Title = "Favorite Rarity",
    Content = "Select the rarity that will be auto favorite.",
    Options = rar,
    Default = {"Legendary","Mythic","SECRET"},
    Multi = true,
    Callback = function(v)
        _G.FavSystem.Tiers = v
    end
})

x4:AddDropdown({
    Title = "Favorite Mutation",
    Content = "Select the mutation that will be auto favorite.",
    Options = muts,
    Default = {},
    Multi = true,
    Callback = function(v)
        _G.FavSystem.Muts = v
    end
})

x4:AddToggle({
    Title = "Auto Favorite Fish",
    Default = false,
    Callback = function(state)
        if state then
            if _G.FavSystem.Conn then _G.FavSystem.Conn:Disconnect() end
            _G.FavSystem.Conn = _G.FavSystem.REN.OnClientEvent:Connect(favFish)
        else
            if _G.FavSystem.Conn then
                _G.FavSystem.Conn:Disconnect()
                _G.FavSystem.Conn = nil
            end
        end
    end
})

x4 = Tabs.Auto:AddSection("Auto Sell")

Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
RunService = game:GetService("RunService")

player = Players.LocalPlayer

SellAllRF = ReplicatedStorage
    .Packages._Index["sleitnick_net@0.2.0"]
    .net["RF/SellAllItems"]

ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
Data = require(ReplicatedStorage.Packages.Replion).Client:WaitReplion("Data")

_G.AutoSellCount = false
_G.AutoSellMinute = false
_G.SellAt = 100
_G.SellMinute = 5

Selling = false
LastSell = 0

function getFishCount()
    items = Data:GetExpect({ "Inventory", "Items" })
    count = 0
    for _, v in pairs(items) do
        itemData = ItemUtility.GetItemDataFromItemType("Items", v.Id)
        if itemData and itemData.Data and itemData.Data.Type == "Fish" then
            count += 1
        end
    end
    return count
end

-- INPUT JUMLAH IKAN
x4:AddInput({
    Title = "Auto Sell When Fish â‰¥",
    Content = "Contoh: 100",
    Default = tostring(_G.SellAt),
    Callback = function(value)
        n = tonumber(value)
        if n and n > 0 then
            _G.SellAt = math.floor(n)
        end
    end
})

-- TOGGLE AUTO SELL BERDASARKAN JUMLAH
x4:AddToggle({
    Title = "Auto Sell (By Fish Count)",
    Content = "Auto sell saat jumlah ikan tercapai.",
    Default = false,
    Callback = function(state)
        _G.AutoSellCount = state
    end
})

-- INPUT MENIT
x4:AddInput({
    Title = "Auto Sell Interval (Minute)",
    Content = "Contoh: 5",
    Default = tostring(_G.SellMinute),
    Callback = function(value)
        n = tonumber(value)
        if n and n > 0 then
            _G.SellMinute = math.floor(n)
        end
    end
})

-- TOGGLE AUTO SELL BERDASARKAN WAKTU
x4:AddToggle({
    Title = "Auto Sell (By Minute)",
    Content = "Auto sell setiap interval waktu.",
    Default = false,
    Callback = function(state)
        _G.AutoSellMinute = state
        if state then
            LastSell = os.clock()
        end
    end
})

-- LOOP AUTO SELL
RunService.Heartbeat:Connect(function()
    if Selling then return end

    -- SELL BERDASARKAN JUMLAH IKAN
    if _G.AutoSellCount and getFishCount() >= _G.SellAt then
        Selling = true
        pcall(function()
            SellAllRF:InvokeServer()
        end)
        task.delay(1.5, function()
            Selling = false
        end)
        return
    end

    -- SELL BERDASARKAN WAKTU
    if _G.AutoSellMinute and os.clock() - LastSell >= (_G.SellMinute * 60) then
        if getFishCount() > 0 then
            Selling = true
            pcall(function()
                SellAllRF:InvokeServer()
            end)
            LastSell = os.clock()
            task.delay(1.5, function()
                Selling = false
            end)
        else
            LastSell = os.clock()
        end
    end
end)

x4 = Tabs.Auto:AddSection("Event Pirate")

local autoClaimClassicState, autoClaimClassicThread = false, nil
local RE_ClaimEventReward = nil

pcall(function()
    RE_ClaimEventReward =
        game:GetService("ReplicatedStorage")
        :WaitForChild("Packages", 10)
        :WaitForChild("_Index", 10)
        :WaitForChild("sleitnick_net@0.2.0", 10)
        :WaitForChild("net", 10)
        :WaitForChild("RE/ClaimEventReward", 10)
end)

x4:AddToggle({
    Title = "Auto Claim Pirate Event Rewards",
    Default = false,
    Callback = function(s)
        autoClaimClassicState = s

        if s then
            if not RE_ClaimEventReward then
                RE_ClaimEventReward =
                    game:GetService("ReplicatedStorage")
                    .Packages._Index["sleitnick_net@0.2.0"]
                    .net:FindFirstChild("RE/ClaimEventReward")
            end

            if not RE_ClaimEventReward then
                Lexs("Remote Claim Reward tidak ditemukan")
                return
            end

            Lexs("Auto Claim Pirate Event: ON")

            if autoClaimClassicThread then
                task.cancel(autoClaimClassicThread)
            end

            autoClaimClassicThread = task.spawn(function()
                while autoClaimClassicState do
                    for i = 1, 15 do
                        if not autoClaimClassicState then break end
                        pcall(function()
                            RE_ClaimEventReward:FireServer(i)
                        end)
                        task.wait(0.1)
                    end
                    task.wait(60)
                end
            end)
        else
            if autoClaimClassicThread then
                task.cancel(autoClaimClassicThread)
                autoClaimClassicThread = nil
            end
        end
    end
})

-- =========================
-- Pirate Treasure Chest
-- =========================

local autoClaimTreasureState = false
local autoClaimTreasureThread = nil

local Players = game:GetService("Players")
local plr = Players.LocalPlayer

local START_CFRAME = CFrame.new(3263, 5, 3686)
local STORAGE = workspace:WaitForChild("PirateChestStorage")
local LOOP_DELAY = 1

local triedChests = {}

local function getHRP()
    local char = plr.Character or plr.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

local function teleport(cf)
    local hrp = getHRP()
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.CFrame = cf + Vector3.new(0, 3, 0)
end

local function getInteractable(obj)
    local p = obj:FindFirstChildWhichIsA("ProximityPrompt", true)
    if p and p.Enabled then return p end
    local c = obj:FindFirstChildWhichIsA("ClickDetector", true)
    return c
end

local function interactOnce(obj)
    local i = getInteractable(obj)
    if not i then return false end
    if i:IsA("ProximityPrompt") then
        fireproximityprompt(i, 1)
    else
        fireclickdetector(i)
    end
    return true
end

local function getRandomChest()
    local valid = {}
    for _, v in ipairs(STORAGE:GetChildren()) do
        if not triedChests[v] and getInteractable(v) then
            table.insert(valid, v)
        end
    end
    if #valid == 0 then return end
    return valid[math.random(#valid)]
end

x4:AddToggle({
    Title = "Auto Claim Treasure Chest",
    Default = false,
    Callback = function(state)
        autoClaimTreasureState = state

        if state then
            Lexs("Auto Claim Treasure Chest: ON")
            triedChests = {}

            if autoClaimTreasureThread then
                task.cancel(autoClaimTreasureThread)
            end

            autoClaimTreasureThread = task.spawn(function()
                teleport(START_CFRAME)
                task.wait(0.6)

                while autoClaimTreasureState do
                    local chest = getRandomChest()
                    if not chest then
                        autoClaimTreasureState = false
                        Lexs("Semua Treasure Chest sudah di-claim")
                        break
                    end

                    triedChests[chest] = true

                    local part =
                        chest:IsA("Model")
                        and (chest.PrimaryPart or chest:FindFirstChildWhichIsA("BasePart"))
                        or chest

                    if part then
                        teleport(part.CFrame)
                        task.wait(0.4)
                        interactOnce(chest)
                    end

                    task.wait(LOOP_DELAY)
                end
            end)
        else
            if autoClaimTreasureThread then
                task.cancel(autoClaimTreasureThread)
                autoClaimTreasureThread = nil
            end
        end
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local c = { d = false, e = 1.6, f = 0.37 }

local g = ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

local h, i, j, k, l
pcall(function()
    h = g:WaitForChild("RF/ChargeFishingRod")
    i = g:WaitForChild("RF/RequestFishingMinigameStarted")
    j = g:WaitForChild("RE/FishingCompleted")
    k = g:WaitForChild("RE/EquipToolFromHotbar")
    l = g:WaitForChild("RF/CancelFishingInputs")
end)

local m = nil
local n = nil

local function p()
    task.spawn(function()
        pcall(function()
            l:InvokeServer()
            h:InvokeServer(math.huge)
            i:InvokeServer(-139.63, 0.996)
        end)
    end)

    task.spawn(function()
        task.wait(c.f)
        if c.d then
            pcall(j.FireServer, j)
        end
    end)
end

local function w()
    n = task.spawn(function()
        while c.d do
            pcall(k.FireServer, k, 1)
            task.wait(1.5)
        end
    end)

    while c.d do
        p()
        task.wait(c.e)
    end
end

local function x(state)
    c.d = state
    if state then
        if m then task.cancel(m) end
        if n then task.cancel(n) end
        m = task.spawn(w)
    else
        if m then task.cancel(m) end
        if n then task.cancel(n) end
        m = nil
        n = nil
        pcall(l.InvokeServer, l)
    end
end

netFolder = ReplicatedStorage:WaitForChild('Packages')
    :WaitForChild('_Index')
    :WaitForChild('sleitnick_net@0.2.0')
    :WaitForChild('net')
Remotes = {}
Remotes.RF_RequestFishingMinigameStarted = netFolder:WaitForChild("RF/RequestFishingMinigameStarted")
Remotes.RF_ChargeFishingRod = netFolder:WaitForChild("RF/ChargeFishingRod")
Remotes.RF_CancelFising = netFolder:WaitForChild('RF/CancelFishingInputs')
Remotes.RF_CancelFishing = netFolder:WaitForChild("RF/CancelFishingInputs")
Remotes.chargeRod = netFolder:WaitForChild('RF/ChargeFishingRod')
Remotes.RE_FishingCompleted = netFolder:WaitForChild("RE/FishingCompleted")
Remotes.RF_AutoFish = netFolder:WaitForChild("RF/UpdateAutoFishingState")

toggleState = {
    autoFishing = false,
    blatantRunning = false,
}

FishingController = require(
    ReplicatedStorage:WaitForChild('Controllers')
        :WaitForChild('FishingController')
)

local oldCharge = FishingController.RequestChargeFishingRod
FishingController.RequestChargeFishingRod = function(...)
    if toggleState.blatantRunning or toggleState.autoFishing then
        return
    end
	return oldCharge(...)
end

local isAutoRunning = false

local isSuperInstantRunning = false
_G.ReelSuper = 1.15
     toggleState.completeDelays = 0.30
     toggleState.delayStart = 0.2
    local function autoEquipSuper()
        local success, err = pcall(function()
            Remotes.RE_EquipTool:FireServer(1)
        end)
        if success then
        end
    end

    local function superInstantFishingCycle()
        task.spawn(function()
            Remotes.RF_CancelFishing:InvokeServer()
            Remotes.RF_ChargeFishingRod:InvokeServer(tick())
            Remotes.RF_RequestFishingMinigameStarted:InvokeServer(-139.63796997070312, 0.9964792798079721)
            task.wait(toggleState.completeDelays)
            Remotes.RE_FishingCompleted:FireServer()
        end)
    end

    local function doSuperFishingFlow()
        superInstantFishingCycle()
    end

local function startSuperInstantFishing()
    if isSuperInstantRunning then return end
    isSuperInstantRunning = true

    task.spawn(function()
        while isSuperInstantRunning do
            superInstantFishingCycle()
            task.wait(math.max(_G.ReelSuper, 0.1))
        end
    end)
end

    local function stopSuperInstantFishing()
        isSuperInstantRunning = false
        print('Super Instant Fishing stopped')
    end

x5 = Tabs.Exc:AddSection("Blantant V1")

x5:AddToggle({
    Title = "Blatant Mode",
    Content = "Super Instant Fishing",
    Default = false,
    Callback = function(state)
        toggleState.blatantRunning = state
        Remotes.RF_AutoFish:InvokeServer(state)

        if state then
            startSuperInstantFishing()
        else
            stopSuperInstantFishing()
        end
    end
})

x5:AddInput({
    Title = "Reel Delay",
    Content = "Delay (Seconds)",
    Default = tostring(_G.ReelSuper),
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 0 then
            _G.ReelSuper = num
            print("ReelSuper updated to:", num)
        end
    end
})

x5:AddInput({
    Title = "Complete Delay",
    Content = "Delay (Seconds)",
    Default = tostring(toggleState.completeDelays),
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            toggleState.completeDelays = num
        end
    end
})

x5:AddButton({
    Title = "Recovery Fishing",
    Callback = function()
        pcall(function()
            ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"]
                .net["RF/CancelFishingInputs"]
                :InvokeServer()
        end)
        Lexs("Fishing recovered")
    end
})

x5 = Tabs.Exc:AddSection("Blantant V2")

x5:AddButton({
    Title = "X7 OLD UI",
    Callback = function()
        loadstring(game:HttpGet("https://pastefy.app/ZMMoMZ9U/raw"))()
    end
})

x5 = Tabs.Exc:AddSection("Blantant V3")

_G.FishingRemotes = _G.FishingRemotes or {}

if not _G.FishingRemotes.Initialized then
    local RS, net = game:GetService("ReplicatedStorage"), nil
    net = RS:WaitForChild("Packages"):WaitForChild("_Index")
        :WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")

    _G.FishingRemotes.RFC = net:WaitForChild("RF/ChargeFishingRod")
    _G.FishingRemotes.RFS = net:WaitForChild("RF/RequestFishingMinigameStarted")
    _G.FishingRemotes.RFK = net:WaitForChild("RF/CancelFishingInputs")
    _G.FishingRemotes.RFU = net:WaitForChild("RF/UpdateAutoFishingState")
    _G.FishingRemotes.REF = net:WaitForChild("RE/FishingCompleted")
    _G.FishingRemotes.REM = net:WaitForChild("RE/FishingMinigameChanged")
    _G.FishingRemotes.Equip = net:WaitForChild("RE/EquipToolFromHotbar")
    _G.FishingRemotes.Unequip = net:WaitForChild("RE/UnequipToolFromHotbar")
    _G.FishingRemotes.Initialized = true
end

local active, fishingThread, equipThread, casts, start = false, nil, nil, 0, 0
local CD, FD, KD = .001, .68, .299
local Players, LocalPlayer = game:GetService("Players"), nil

local function safe(f) task.spawn(function() pcall(f) end) end
local function getPlayer() if not LocalPlayer then LocalPlayer = Players.LocalPlayer end return LocalPlayer end

local function fishingLoop()
    local R,S,K,F = _G.FishingRemotes.RFC,_G.FishingRemotes.RFS,_G.FishingRemotes.RFK,_G.FishingRemotes.REF
    while active do
        local t,r,t2,r2 = tick(),tick(),tick(),tick()
        safe(function() R:InvokeServer({[1]=t}) end) task.wait(CD)
        safe(function() S:InvokeServer(1,0,r) end) casts+=1
        safe(function() R:InvokeServer({[1]=t2}) end) task.wait(CD)
        safe(function() S:InvokeServer(1,0,r2) end) casts+=1
        task.wait(FD) safe(function() F:FireServer() F:FireServer() end)
        task.wait(KD) safe(function() K:InvokeServer() end) task.wait(0.001)
    end
end

local function equipLoop()
    local E,U = _G.FishingRemotes.Equip,_G.FishingRemotes.Unequip
    while active do safe(function() E:FireServer(1) end) task.wait(100) end
    safe(function() U:FireServer() end)
end

_G.FishingRemotes.REM.OnClientEvent:Connect(function()
    if not active then return end
    task.spawn(function()
        task.wait(FD)
        safe(function() _G.FishingRemotes.REF:FireServer() end)
        task.wait(KD)
        safe(function() _G.FishingRemotes.RFK:InvokeServer() end)
    end)
end)

x5:AddInput({
    Title = "Cast Delay",
    Default = tostring(CD),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then CD = n end
    end
})

x5:AddInput({
    Title = "Complete Delay",
    Default = tostring(FD),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then FD = n end
    end
})

x5:AddInput({
    Title = "Cancel Delay",
    Default = tostring(KD),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then KD = n end
    end
})

x5:AddToggle({
    Title = "Enable Blantant V3",
    Content = "Ultra fast perfect",
    Default = false,
    Callback = function(s)
        active = s
        local P,RU,RK,UE = getPlayer(),_G.FishingRemotes.RFU,_G.FishingRemotes.RFK,_G.FishingRemotes.Unequip
        if s then
            casts,start = 0,tick()
            pcall(function() P:SetAttribute("InCutscene", true) end)
            safe(function() RU:InvokeServer(true) end)
            fishingThread = task.spawn(fishingLoop)
            equipThread = task.spawn(equipLoop)
        else
            if fishingThread then task.cancel(fishingThread) fishingThread=nil end
            if equipThread then task.cancel(equipThread) equipThread=nil end
            safe(function() RU:InvokeServer(false) end)
            safe(function() UE:FireServer() end)
            task.wait(.2)
            safe(function() RK:InvokeServer() end)
        end
    end
})

x5:AddButton({
    Title = "Recovery Fishing",
    Callback = function()
        pcall(function()
            ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"]
                .net["RF/CancelFishingInputs"]
                :InvokeServer()
        end)
        Lexs("Fishing recovered")
    end
})

x5 = Tabs.Exc:AddSection("Skin Animation")

_G.Player = game:GetService("Players").LocalPlayer
_G.RS = game:GetService("ReplicatedStorage")
_G.Net = _G.RS:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

_G.BlockRodAnim = false
_G.CurrentTrack = nil
_G.ActiveAnim = nil

_G.HookAnimator = function(char)
    _G.Humanoid = char:WaitForChild("Humanoid")
    _G.Animator = _G.Humanoid:WaitForChild("Animator")
    _G.Animator.AnimationPlayed:Connect(function(track)
        if _G.BlockRodAnim and track ~= _G.CurrentTrack then
            track:Stop()
        end
    end)
end

if _G.Player.Character then
    _G.HookAnimator(_G.Player.Character)
end

_G.Player.CharacterAdded:Connect(function(char)
    _G.HookAnimator(char)
    _G.CurrentTrack = nil
end)

local function PlayFishAnim(animName)
    _G.BlockRodAnim = true
    if _G.CurrentTrack then
        _G.CurrentTrack:Stop()
    end
    _G.CurrentTrack = _G.Animator:LoadAnimation(
        _G.RS.Modules.Animations[animName]
    )
    _G.CurrentTrack.Priority = Enum.AnimationPriority.Action
    _G.CurrentTrack.Looped = false
    _G.CurrentTrack:Play()
    task.delay(1, function()
        _G.BlockRodAnim = false
    end)
end

_G.AutoHoly = false
x5:AddToggle({
    Title = "Holy Trident",
    Default = false,
    Callback = function(v)
        _G.AutoHoly = v
        if v then _G.ActiveAnim = "Holy Trident - FishCaught" end
    end
})

_G.AutoEclipse = false
x5:AddToggle({
    Title = "Eclipse Katana",
    Default = false,
    Callback = function(v)
        _G.AutoEclipse = v
        if v then _G.ActiveAnim = "Eclipse Katana - FishCaught" end
    end
})

_G.AutoBan = false
x5:AddToggle({
    Title = "1x1x1x1 Ban Hammer",
    Default = false,
    Callback = function(v)
        _G.AutoBan = v
        if v then _G.ActiveAnim = "1x1x1x1 Ban Hammer - FishCaught" end
    end
})

_G.AutoKrampus = false
x5:AddToggle({
    Title = "Frozen Krampus Scythe",
    Default = false,
    Callback = function(v)
        _G.AutoKrampus = v
        if v then _G.ActiveAnim = "Frozen Krampus Scythe - FishCaught" end
    end
})

_G.AutoVanquisher = false
x5:AddToggle({
    Title = "The Vanquisher",
    Default = false,
    Callback = function(v)
        _G.AutoVanquisher = v
        if v then _G.ActiveAnim = "The Vanquisher - FishCaught" end
    end
})

_G.AutoGinger = false
x5:AddToggle({
    Title = "Gingerbread Katana",
    Default = false,
    Callback = function(v)
        _G.AutoGinger = v
        if v then _G.ActiveAnim = "Gingerbread Katana - FishCaught" end
    end
})

_G.AutoParasol = false
x5:AddToggle({
    Title = "Christmas Parasol",
    Default = false,
    Callback = function(v)
        _G.AutoParasol = v
        if v then _G.ActiveAnim = "Christmas Parasol - FishCaught" end
    end
})

_G.AutoBlackhole = false
x5:AddToggle({
    Title = "Blackhole Sword",
    Default = false,
    Callback = function(v)
        _G.AutoBlackhole = v
        if v then _G.ActiveAnim = "Blackhole Sword - FishCaught" end
    end
})

_G.AutoFlower = false
x5:AddToggle({
    Title = "Eternal Flower",
    Default = false,
    Callback = function(v)
        _G.AutoFlower = v
        if v then _G.ActiveAnim = "Eternal Flower - FishCaught" end
    end
})

_G.AutoBinary = false -- new animation
x5:AddToggle({
    Title = "Binary Edge",
    Default = false,
    Callback = function(v)
        _G.AutoBinary = v
        if v then _G.ActiveAnim = "Binary Edge - FishCaught" end
    end
})

_G.AutoCorrupt = false
x5:AddToggle({
    Title = "Corruption Edge",
    Default = false,
    Callback = function(v)
        _G.AutoCorrupt = v
        if v then _G.ActiveAnim = "Corruption Edge - FishCaught" end
    end
})

_G.AutoSoul = false
x5:AddToggle({
    Title = "Soul Scythe",
    Default = false,
    Callback = function(v)
        _G.AutoSoul = v
        if v then _G.ActiveAnim = "Soul Scythe - FishCaught" end
    end
})

_G.Net:WaitForChild("RE/FishCaught").OnClientEvent:Connect(function()
    if not _G.ActiveAnim then return end
    PlayFishAnim(_G.ActiveAnim)
end)

x6 = Tabs.Shop:AddSection("Boost Server")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GiftingController = require(
    ReplicatedStorage:WaitForChild("Controllers"):WaitForChild("GiftingController")
)

_G.SelectedGift = "x2 Luck"

x6:AddDropdown({
    Title = "Select Luck Gift",
    Content = "Select the type of luck gift you want to open.",
    Options = {
        "x2 Luck",
        "x4 Luck",
        "x8 Luck"
    },
    Default = "x2 Luck",
    Callback = function(value)
        _G.SelectedGift = value
    end
})


x6:AddButton({
    Title = "Open Gift",
    Callback = function()
        Lexs("Opening gift: "..tostring(_G.SelectedGift))
        pcall(function()
            GiftingController:Open(_G.SelectedGift)
        end)
    end
})

x6 = Tabs.Shop:AddSection("Skin Rod")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GiftingController = require(
    ReplicatedStorage:WaitForChild("Controllers"):WaitForChild("GiftingController")
)

_G.SelectedGift = "Frozen Krampus Scythe"

x6:AddDropdown({
    Title = "Select Gift",
    Content = "Select the skin gift you want to open.",
    Options = {
        "Frozen Krampus Scythe",
        "Gingerbread Katana",
        "Christmas Parasol"
    },
    Default = "Frozen Krampus Scythe",
    Callback = function(value)
        _G.SelectedGift = value
    end
})

x6:AddButton({
    Title = "Open Gift",
    Callback = function()
        Lexs("Opening gift: " .. tostring(_G.SelectedGift))
        pcall(function()
            GiftingController:Open(_G.SelectedGift)
        end)
    end
})

x6 = Tabs.Shop:AddSection("Shop Rod")

local RS = game:GetService("ReplicatedStorage")
local RF = RS.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseFishingRod"]

local R = {
    ["Luck Rod"] = 79,
    ["Carbon Rod"] = 76,
    ["Grass Rod"] = 85,
    ["Demascus Rod"] = 77,
    ["Ice Rod"] = 78,
    ["Lucky Rod"] = 4,
    ["Midnight Rod"] = 80,
    ["Steampunk Rod"] = 6,
    ["Chrome Rod"] = 7,
    ["Astral Rod"] = 5,
    ["Ares Rod"] = 126,
    ["Angler Rod"] = 168,
    ["Bamboo Rod"] = 258
}

local N = {
    "Luck Rod (350 Coins)",
    "Carbon Rod (900 Coins)",
    "Grass Rod (1.5k Coins)",
    "Demascus Rod (3k Coins)",
    "Ice Rod (5k Coins)",
    "Lucky Rod (15k Coins)",
    "Midnight Rod (50k Coins)",
    "Steampunk Rod (215k Coins)",
    "Chrome Rod (437k Coins)",
    "Astral Rod (1M Coins)",
    "Ares Rod (3M Coins)",
    "Angler Rod (8M Coins)",
    "Bamboo Rod (12M Coins)"
}

local M = {
    ["Luck Rod (350 Coins)"] = "Luck Rod",
    ["Carbon Rod (900 Coins)"] = "Carbon Rod",
    ["Grass Rod (1.5k Coins)"] = "Grass Rod",
    ["Demascus Rod (3k Coins)"] = "Demascus Rod",
    ["Ice Rod (5k Coins)"] = "Ice Rod",
    ["Lucky Rod (15k Coins)"] = "Lucky Rod",
    ["Midnight Rod (50k Coins)"] = "Midnight Rod",
    ["Steampunk Rod (215k Coins)"] = "Steampunk Rod",
    ["Chrome Rod (437k Coins)"] = "Chrome Rod",
    ["Astral Rod (1M Coins)"] = "Astral Rod",
    ["Ares Rod (3M Coins)"] = "Ares Rod",
    ["Angler Rod (8M Coins)"] = "Angler Rod",
    ["Bamboo Rod (12M Coins)"] = "Bamboo Rod"
}

local S = N[1]

x6:AddDropdown({
    Title = "Select Rod",
    Content = "Select the fishing rod you want to buy.",
    Options = N,
    Default = S,
    Callback = function(value)
        S = value
    end
})

x6:AddButton({
    Title = "Buy Rod",
    Callback = function()
        local k = M[S]
        if k and R[k] then
            Lexs("Buy rods: " .. k)
            pcall(function()
                RF:InvokeServer(R[k])
            end)
        end
    end
})

x6 = Tabs.Shop:AddSection("Shop Bait")

local RS = game:GetService("ReplicatedStorage")
local RF = RS.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseBait"]

local B = {
    ["Luck Bait"] = 2,
    ["Midnight Bait"] = 3,
    ["Nature Bait"] = 10,
    ["Chroma Bait"] = 6,
    ["Dark Matter Bait"] = 8,
    ["Corrupt Bait"] = 15,
    ["Aether Bait"] = 16,
    ["Floral Bait"] = 20
}

local N = {
    "Luck Bait (1k Coins)",
    "Midnight Bait (3k Coins)",
    "Nature Bait (83.5k Coins)",
    "Chroma Bait (290k Coins)",
    "Dark Matter Bait (630k Coins)",
    "Corrupt Bait (1.15M Coins)",
    "Aether Bait (3.7M Coins)",
    "Floral Bait (4M Coins)"
}

local M = {
    ["Luck Bait (1k Coins)"] = "Luck Bait",
    ["Midnight Bait (3k Coins)"] = "Midnight Bait",
    ["Nature Bait (83.5k Coins)"] = "Nature Bait",
    ["Chroma Bait (290k Coins)"] = "Chroma Bait",
    ["Dark Matter Bait (630k Coins)"] = "Dark Matter Bait",
    ["Corrupt Bait (1.15M Coins)"] = "Corrupt Bait",
    ["Aether Bait (3.7M Coins)"] = "Aether Bait",
    ["Floral Bait (4M Coins)"] = "Floral Bait"
}

local S = N[1]

x6:AddDropdown({
    Title = "Select Bait",
    Content = "Select the bait you want to buy.",
    Options = N,
    Default = S,
    Callback = function(value)
        S = value
    end
})

x6:AddButton({
    Title = "Buy Bait",
    Callback = function()
        local k = M[S]
        if k and B[k] then
            Lexs("Buy bait: " .. k)
            pcall(function()
                RF:InvokeServer(B[k])
            end)
        end
    end
})

x6 = Tabs.Shop:AddSection("Shop Weather")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RFPurchaseWeatherEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseWeatherEvent"]

local weatherKeyMap = {
    ["Wind (10k Coins)"] = "Wind",
    ["Snow (15k Coins)"] = "Snow",
    ["Cloudy (20k Coins)"] = "Cloudy",
    ["Storm (35k Coins)"] = "Storm",
    ["Radiant (50k Coins)"] = "Radiant",
    ["Shark Hunt (300k Coins)"] = "Shark Hunt"
}

local weatherNames = {
    "Wind (10k Coins)",
    "Snow (15k Coins)",
    "Cloudy (20k Coins)",
    "Storm (35k Coins)",
    "Radiant (50k Coins)",
    "Shark Hunt (300k Coins)"
}

local selectedWeathers = {}
local autoBuyEnabled = false
local buyDelay = 540

x6:AddDropdown({
    Title = "Select Weather",
    Content = "Select the weather you want to buy.",
    Options = weatherNames,
    Multi = true,
    Callback = function(values)
        selectedWeathers = values
    end
})

x6:AddInput({
    Title = "Buy Delay (minutes)",
    Content = "Default 9 Minutes (Just Settings 1)",
    Placeholder = "1",
    Callback = function(input)
        local num = tonumber(input)
        if num and num > 0 then
            buyDelay = num * 60
        end
    end
})

local function startAutoBuy()
    task.spawn(function()
        while autoBuyEnabled do
            for _, displayName in ipairs(selectedWeathers) do
                local key = weatherKeyMap[displayName]
                if key then
                    pcall(function()
                        RFPurchaseWeatherEvent:InvokeServer(key)
                    end)
                end
            end
            task.wait(buyDelay)
        end
    end)
end

x6:AddToggle({
    Title = "Auto Buy Weather",
    Default = false,
    Callback = function(state)
        autoBuyEnabled = state
        if state then
            startAutoBuy()
        end
    end
})

x7 = Tabs.Teleport:AddSection("Island & Fishing Spot Teleport")

local IslandLocations = {
    ["Ancient Jungle"] = Vector3.new(1518, 1, -186),
    ["Coral Refs"] = Vector3.new(-2855, 47, 1996),
    ["Crater Island"] = Vector3.new(997, 1, 5012),
    ["Enchant Room"] = Vector3.new(3221, -1303, 1406),
    ["Enchant Room 2"] = Vector3.new(1480, 126, -585),
    ["Esoteric Island"] = Vector3.new(1990, 5, 1398),
    ["Fisherman Island"] = Vector3.new(-64, 3, 2767),
    ["Kohana Volcano"] = Vector3.new(-545.302429, 17.1266193, 118.870537),
    ["Kohana"] = Vector3.new(-603, 3, 719),
    ["Lost Isle"] = Vector3.new(-3643, 1, -1061),
    ["Sacred Temple"] = Vector3.new(1498, -23, -644),
    ["Sysyphus Statue"] = Vector3.new(-3783.26807, -135.073914, -949.946289),
    ["Treasure Room"] = Vector3.new(-3600, -267, -1575),
    ["Tropical Grove"] = Vector3.new(-2091, 6, 3703),
    ["Underground Cellar"] = Vector3.new(2135, -93, -701),
    ["Weather Machine"] = Vector3.new(-1508, 6, 1895),
    ["Ancient Ruin"] = Vector3.new(6051, -541, 4414),
    ["Pirate Cove"] = Vector3.new(3248, 9, 3567),
    ["Crystal Depths"] = Vector3.new(5750, -905, 15381),
}

local SelectedIsland = nil

x7:AddDropdown({
    Title = "Select Island",
    Content = "Select the teleport destination island",
    Options = (function()
        local t = {}
        for k in pairs(IslandLocations) do
            table.insert(t, k)
        end
        table.sort(t)
        return t
    end)(),
    Callback = function(v)
        SelectedIsland = v
    end
})

x7:AddButton({
    Title = "Teleport to Island",
    Callback = function()
        if SelectedIsland and IslandLocations[SelectedIsland]
        and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
            Player.Character.HumanoidRootPart.CFrame =
                CFrame.new(IslandLocations[SelectedIsland])
        end
    end
})

local FishingLocations = {
    ["Levers 1"] = Vector3.new(1475,4,-847),
    ["Levers 2"] = Vector3.new(882,5,-321),
    ["levers 3"] = Vector3.new(1425,6,126),
    ["levers 4"] = Vector3.new(1837,4,-309),
    ["Sysyphus Statue"] = Vector3.new(-3710, -97, -952),
    ["King Jelly Spot (For quest elemental)"] = Vector3.new(1473.60, 3.58, -328.23),
    ["El Shark Gran Maja Spot"] = Vector3.new(1526, 4, -629),
    ["Ancient Lochness"] = Vector3.new(6078, -586, 4629),
    ["Pirate Cove"] = Vector3.new(3552, 67, 3397),
    ["Kohana WaterFall"] = Vector3.new(-603, 15, 526),
    ["Pirate Treasure Room"] = Vector3.new(3331, -297, 3099),
    ["Crystal Depths"] = Vector3.new(5848, -903, 15417),
}

local SelectedFishing = nil

x7:AddDropdown({
    Title = "Select Fishing Spot",
    Content = "Select the fishing spot to teleport",
    Options = (function()
        local t = {}
        for k in pairs(FishingLocations) do
            table.insert(t, k)
        end
        table.sort(t)
        return t
    end)(),
    Callback = function(v)
        SelectedFishing = v
    end
})

x7:AddButton({
    Title = "Teleport to Fishing Spot",
    Callback = function()
        if SelectedFishing and FishingLocations[SelectedFishing]
        and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
            Player.Character.HumanoidRootPart.CFrame =
                CFrame.new(FishingLocations[SelectedFishing])
        end
    end
})

x7 = Tabs.Teleport:AddSection("Teleport Player")

local P = game:GetService("Players")
local LP = P.LocalPlayer
local S
local D

local function L()
    local t = {}
    for _, p in ipairs(P:GetPlayers()) do
        if p ~= LP then
            t[#t + 1] = p.Name
        end
    end
    return t
end

D = x7:AddDropdown({
    Title = "Teleport Target",
    Content = "Select the player you want to teleport",
    Options = L(),
    Callback = function(v)
        S = v
    end
})

x7:AddButton({
    Title = "Teleport to Player",
    Callback = function()
        local T = S and P:FindFirstChild(S)
        if T and T.Character and T.Character:FindFirstChild("HumanoidRootPart")
        and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
            LP.Character.HumanoidRootPart.CFrame =
                T.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
        end
    end
})

x7:AddButton({
    Title = "Refresh Player List",
    Callback = function()
        local n = L()

        if D.SetOptions then
            D:SetOptions(n)
        elseif D.Update then
            D:Update(n)
        elseif D.Refresh then
            D:Refresh(n)
        end

        if n[1] then
            S = n[1]
            if D.Set then
                D:Set(n[1])
            end
        end

        Lexs("Player list successfully refreshed (" .. tostring(#n) .. " Players)")
    end
})

x8 = Tabs.Event:AddSection("Teleport Event")

local P = game:GetService("Players").LocalPlayer
local RS = game:GetService("RunService")

local currentEvent = "Megalodon Hunt"
local teleporting = false
local lastPosition = nil
local bodyVelocity = nil
local connection = nil
local frozen = false
local done = false

local EventSettings = {
    isTeleporting = false,
    currentLocation = "Megalodon Hunt"
}

teleporting = EventSettings.isTeleporting
currentEvent = EventSettings.currentLocation

local function findEvent(eventName)
    if eventName == "Worm Fish" then
        for _, v in ipairs(workspace:GetChildren()) do
            local model = v:FindFirstChild("Model")
            if model then
                local part = model:GetChildren()[3]
                if part and part:IsA("BasePart") then
                    return part
                end
            end
        end
    else
        for _, v in ipairs(workspace:GetDescendants()) do
            if v.Name == eventName then
                if v:IsA("Model") then
                    return v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart", true)
                elseif v:IsA("BasePart") then
                    return v
                end
            end
        end
    end
    return nil
end

local function freeze(position)
    local character = P.Character
    if not character or character:GetAttribute("Dead") then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    if bodyVelocity then
        bodyVelocity:Destroy()
    end

    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
    bodyVelocity.P = 10000
    bodyVelocity.Parent = humanoidRootPart

    pcall(function()
        humanoidRootPart.CFrame = CFrame.new(position)
    end)

    frozen = true
    done = true
end

local function unfreeze()
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
    frozen = false
    done = false
end

local function savePosition()
    for _ = 1, 5 do
        local character = P.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            lastPosition = humanoidRootPart.Position
            return true
        end
        task.wait(0.2)
    end
    return false
end

local function teleportToEvent(eventPart)
    if not eventPart then return end
    local position = eventPart.Position
    freeze(Vector3.new(
        position.X + math.random(-10, 10),
        position.Y + 80,
        position.Z + math.random(-10, 10)
    ))
end

local function returnToLastPosition()
    if not lastPosition then return end
    unfreeze()
    local humanoidRootPart = P.Character and P.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        humanoidRootPart.CFrame = CFrame.new(lastPosition)
    end
end

local function stopTeleporting()
    if connection then
        connection:Disconnect()
        connection = nil
    end
    if frozen then
        returnToLastPosition()
    end
end

local function startTeleporting()
    if connection then
        connection:Disconnect()
    end

    if not savePosition() then return end

    connection = RS.Heartbeat:Connect(function()
        if not teleporting then
            if frozen then
                returnToLastPosition()
            end
            return
        end

        local character = P.Character
        if not character or character:GetAttribute("Dead") then
            if frozen then
                unfreeze()
            end
            return
        end

        if done then return end

        local eventPart = nil
        for _ = 1, 3 do
            eventPart = findEvent(currentEvent)
            if eventPart then break end
            task.wait(0.1)
        end

        if eventPart then
            if not frozen then
                teleportToEvent(eventPart)
            end
        elseif frozen then
            returnToLastPosition()
        end
    end)
end

-- ======================
-- UI (DROPDOWN & TOGGLE)
-- ======================

x8:AddDropdown({
    Title = "Hunt Location",
    Options = {
        "Megalodon Hunt",
        "Ghost Shark Hunt",
        "Shark Hunt",
        "Worm Fish"
    },
    Default = currentEvent,
    Callback = function(value)
        currentEvent = value
        EventSettings.currentLocation = value

        if teleporting then
            unfreeze()
            task.wait(0.1)
            startTeleporting()
        end
    end
})

x8:AddToggle({
    Title = "Teleport To Game Event",
    Default = teleporting,
    Callback = function(state)
        teleporting = state
        EventSettings.isTeleporting = state

        if state then
            task.wait(0.5)
            startTeleporting()
        else
            stopTeleporting()
        end
    end
})

P.CharacterAdded:Connect(function()
    task.wait(2)
    if teleporting then
        task.wait(1)
        startTeleporting()
    end
end)


-- // Services & Utils //
local Replion = require(game:GetService("ReplicatedStorage").Packages.Replion)
local ItemUtility = require(game:GetService("ReplicatedStorage").Shared.ItemUtility)
local TierUtility = require(game:GetService("ReplicatedStorage").Shared.TierUtility)
    
local function GetPlayerDataReplion()
    return Replion.Client:WaitReplion("Data", 5)
end
    
local function GetRemote(p, n)
    local c = game:GetService("ReplicatedStorage")
    for _, v in ipairs(p) do c = c:WaitForChild(v, 0.5) if not c then return end end
    return c:FindFirstChild(n)
end
local RUIN_DOOR_REMOTE = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net"}, "RE/PlacePressureItem")
    
local function GetHRP() local c = game.Players.LocalPlayer.Character return c and c:FindFirstChild("HumanoidRootPart") end
local function TeleportToLookAt(p, l) local c = game.Players.LocalPlayer.Character local h = c and c:FindFirstChild("HumanoidRootPart") if h then h.CFrame = CFrame.new(p, p + l) end end

-- // ANCIENT LOCHNESS EVENT //
local loknes = Tabs.Event:AddSection("Ancient Lochness Event")
local CountdownParagraph = loknes:AddParagraph({Title="Event Countdown: Waiting...", Content="Status: Trying to sync event...", Icon="clock"})
local StatsParagraph = loknes:AddParagraph({Title="Event Stats: N/A", Content="Timer: N/A\nCaught: N/A\nChance: N/A", Icon="trending-up"})
    
local LOCHNESS_POS, LOCHNESS_LOOK = Vector3.new(6063.347, -585.925, 4713.696), Vector3.new(-0.376, 0, -0.927)
local lastPositionBeforeEvent = nil
    
local function GetEventGUI()
    local ok, g = pcall(function()
        local i = workspace:WaitForChild("!!! DEPENDENCIES", 5):WaitForChild("Event Tracker", 5).Main.Gui.Content.Items
        local s = i.Stats
        return {Countdown=i.Countdown.Label, Timer=s.Timer.Label, Quantity=s.Quantity, Odds=s.Odds}
    end)
    return ok and g or nil
end

local function UpdateEventStats()
    local g = GetEventGUI()
    if not g then
        CountdownParagraph:SetContent("Event Countdown: GUI Not Found âŒ\nMake sure 'Event Tracker' is loaded in workspace.")
        StatsParagraph:SetContent("Event Stats: N/A\nTimer: N/A\nCaught: N/A\nChance: N/A")
        return false
    end
    local c = g.Countdown and (g.Countdown.ContentText or g.Countdown.Text) or "N/A"
    local t = g.Timer and (g.Timer.ContentText or g.Timer.Text) or "N/A"
    local q = g.Quantity and (g.Quantity.ContentText or g.Quantity.Text) or "N/A"
    local o = g.Odds and (g.Odds.ContentText or g.Odds.Text) or "N/A"
    CountdownParagraph:SetContent("Ancient Lochness Start In:\n" .. c)
    StatsParagraph:SetContent("Ancient Lochness Stats\n" .. string.format("- Timer: %s\n- Caught: %s\n- Chance: %s", t, q, o))
    return tostring(t):find("M") and tostring(t):find("S") and not tostring(t):match("^0M 0S")
end
    
local EventSyncThread = nil
local autoJoinEventActive = false
local function RunEventSyncLoop()
    if EventSyncThread then task.cancel(EventSyncThread) end
    EventSyncThread = task.spawn(function()
        local tp = false
        while true do
            local a = UpdateEventStats()
            if autoJoinEventActive then
                if a and not tp then
                    if not lastPositionBeforeEvent then
                        local h = GetHRP()
                        if h then lastPositionBeforeEvent = {Pos=h.Position, Look=h.CFrame.LookVector} end
                    end
                    TeleportToLookAt(LOCHNESS_POS, LOCHNESS_LOOK) tp = true
                elseif tp and not a and lastPositionBeforeEvent then
                    task.wait(15)
                    TeleportToLookAt(lastPositionBeforeEvent.Pos, lastPositionBeforeEvent.Look)
                    lastPositionBeforeEvent, tp = nil, false
                end
            end
            task.wait(0.5)
        end
    end)
end
RunEventSyncLoop()
    
local LochnessToggle = loknes:AddToggle({
    Title = "Auto Join Ancient Lochness Event",
    Content = "Auto teleport to event when active",
    Default = false,
    Callback = function(s)
        autoJoinEventActive = s
        if s then
            CountdownParagraph:SetContent("Event Countdown: Monitoring...\nWatching for Lochness event...")
        else
            CountdownParagraph:SetContent("Event Countdown: Stopped\nEvent monitoring stopped")
        end
    end
})

x9 = Tabs.Trade:AddSection("Auto Trade")

-- Services
local RepStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local ItemUtility = require(RepStorage:WaitForChild("Shared"):WaitForChild("ItemUtility"))
local ReplionClient = require(RepStorage:WaitForChild("Packages"):WaitForChild("Replion")).Client

-- Remote Setup
local RPath = {"Packages", "_Index", "sleitnick_net@0.2.0", "net"}
local function GetRemote(p, n)
    local c = RepStorage
    for _, k in ipairs(p) do
        c = c:WaitForChild(k, 5)
        if not c then return nil end
    end
    return c:FindFirstChild(n)
end
local RF_InitiateTrade = GetRemote(RPath, "RF/InitiateTrade")

-- State Variables
local autoTradeState = false
local autoTradeThread = nil
local tradeHoldFavorite = false
local autoAcceptState = false
local hideFavoriteInDropdown = false
local groupMutationsInDropdown = false
local selectedTradeTargetId = nil
local selectedTradeItemName = nil
local selectedTradeRarity = nil
local tradeDelay = 1
local tradeAmount = 0
local tradeStopAtCoins = 0
local isTradeByCoinActive = false
local tradeQuantity = 1
local selectedMutation = ""
local allMutations = {"Shiny","Albino","Sandy","Noob","Moon Fragment","Festive","Disco","1x1x1x1","Bloodmoon","Color Burn","Corrupt","Fairy Dust","Frozen","Galaxy","Gemstone","Ghost","Gold","Holographic","Lightning","Midnight","Radioactive","Stone"}
local GlobalItemCache = {}

-- Cache Items
task.spawn(function()
    local items = RepStorage:WaitForChild("Items"):GetChildren()
    for _, v in ipairs(items) do
        if v.Name:sub(1, 3) ~= "!!!" then
            table.insert(GlobalItemCache, v.Name)
        end
    end
    table.sort(GlobalItemCache)
end)

-- Auto Accept Hook
task.spawn(function()
    local PromptController, Promise
    pcall(function()
        PromptController = require(RepStorage:WaitForChild("Controllers").PromptController)
        Promise = require(RepStorage:WaitForChild("Packages").Promise)
    end)
    if PromptController and PromptController.FirePrompt then
        local old = PromptController.FirePrompt
        PromptController.FirePrompt = function(self, t, ...)
            if autoAcceptState and type(t) == "string" and t:find("Accept") and t:find("from:") then
                return Promise.new(function(r) task.wait(2) r(true) end)
            end
            return old(self, t, ...)
        end
    end
end)


local function GetFishNameAndRarity(item)
    local name = item.Identifier or "Unknown"
    local rarity = item.Metadata and item.Metadata.Rarity or "COMMON"
    if ItemUtility then
        local d = ItemUtility:GetItemData(item.Id)
        if d and d.Data and d.Data.Name then name = d.Data.Name end
    end
    return name, rarity
end

local function GetMutationName(item)
    if not item.Metadata or not item.Metadata.VariantId then return "No Mutation" end
    local mutations = {
        Shiny = "Shiny",
        Albino = "Albino",
        Sandy = "Sandy",
        Noob = "Noob",
        ["Moon Fragment"] = "Moon Fragment",
        Festive = "Festive",
        Disco = "Disco",
        ["1x1x1x1"] = "1x1x1x1",
        Bloodmoon = "Bloodmoon",
        ["Color Burn"] = "Color Burn",
        Corrupt = "Corrupt",
        ["Fairy Dust"] = "Fairy Dust",
        Frozen = "Frozen",
        Galaxy = "Galaxy",
        Gemstone = "Gemstone",
        Ghost = "Ghost",
        Gold = "Gold",
        Holographic = "Holographic",
        Lightning = "Lightning",
        Midnight = "Midnight",
        Radioactive = "Radioactive",
        Stone = "Stone"
    }
    return mutations[item.Metadata.VariantId] or item.Metadata.VariantId
end

local function GetPlayerDataReplion()
    local s, r = pcall(function() return ReplionClient:WaitReplion("Data") end)
    return s and r or nil
end

local function GetItemsToTrade()
    local r = GetPlayerDataReplion()
    if not r then return {} end
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if not s or not i or not i.Items then return {} end
    
    local out = {}
    for _, item in ipairs(i.Items) do
        local fav = item.IsFavorite or item.Favorited
        if tradeHoldFavorite and fav then continue end
        if typeof(item.UUID) ~= "string" or #item.UUID < 10 then continue end
        
        local name, rar = GetFishNameAndRarity(item)
        local ir = (rar and rar:upper() ~= "COMMON") and rar or "Default"
        local pr = not selectedTradeRarity or ir:upper() == selectedTradeRarity:upper()
        local pn = not selectedTradeItemName or name == selectedTradeItemName
        local mutation = GetMutationName(item)
        local pm = not selectedMutation or selectedMutation == "" or mutation == selectedMutation
        
        if pr and pn and pm then
            table.insert(out, {UUID=item.UUID, Name=name, Id=item.Id, Metadata=item.Metadata or {}, IsFavorite=fav, Mutation=mutation})
        end
    end
    return out
end

local function GetInventoryForScan()
    local r = GetPlayerDataReplion()
    if not r then return {} end
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if not s or not i or not i.Items then return {} end
    
    local out = {}
    for _, item in ipairs(i.Items) do
        local fav = item.IsFavorite or item.Favorited
        if hideFavoriteInDropdown and fav then continue end
        if typeof(item.UUID) ~= "string" or #item.UUID < 10 then continue end
        

        if ItemUtility then
            local d = ItemUtility:GetItemData(item.Id)
            if d and d.Type == "Gear" then continue end
        end
        
        local name, rar = GetFishNameAndRarity(item)
        local mutation = GetMutationName(item)
        
        table.insert(out, {UUID=item.UUID, Name=name, Id=item.Id, Metadata=item.Metadata or {}, IsFavorite=fav, Mutation=mutation})
    end
    return out
end

local function IsItemStillInInventory(u)
    local r = GetPlayerDataReplion()
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if s and i.Items then
        for _, it in ipairs(i.Items) do
            if it.UUID == u then return true end
        end
    end
    return false
end

local function TeleportToPlayer(id)
    local tp = Players:GetPlayerByUserId(id)
    if tp and tp.Character then
        local th = tp.Character:FindFirstChild("HumanoidRootPart")
        local mh = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if th and mh then
            mh.CFrame = th.CFrame * CFrame.new(0, 5, 0)
            return true
        end
    end
    return false
end

local function RunAutoTradeLoop()
    if autoTradeThread then task.cancel(autoTradeThread) end
    autoTradeThread = task.spawn(function()
        local tradeCount = 0
        local acc = 0
        
        if not selectedTradeTargetId then
            Lexs("Pilih target player dulu.")
            return
        end
        
        Lexs("Auto Trade Started")
        local targetQuantity = tradeQuantity > 0 and tradeQuantity or 99999
        local tradedCount = 0
        
        while autoTradeState and tradedCount < targetQuantity do
            -- Check Limits
            if isTradeByCoinActive and tradeStopAtCoins > 0 and acc >= tradeStopAtCoins then
                Lexs(string.format("Target Value Tercapai - Total: %d", acc))
                break
            end
            if tradeAmount > 0 and tradeCount >= tradeAmount then
                Lexs("Limit Tercapai - Jumlah trade terpenuhi.")
                break
            end
            
            -- Teleport to Target
            if not TeleportToPlayer(selectedTradeTargetId) then
                Lexs("Target Hilang - Player keluar / tidak ditemukan.")
                break
            end
            
            -- Get & Trade Items
            local items = GetItemsToTrade()
            if #items > 0 then
                local item = items[1]
                local base = 0
                if ItemUtility then
                    local d = ItemUtility:GetItemData(item.Id)
                    if d then base = d.SellPrice or 0 end
                end
                local mult = item.Metadata.SellMultiplier or 1
                local val = math.floor(base * mult)
                
                local ok = pcall(function() RF_InitiateTrade:InvokeServer(selectedTradeTargetId, item.UUID) end)
                if ok then
                    local st = os.clock()
                    local traded = false
                    repeat
                        task.wait(0.5)
                        if not IsItemStillInInventory(item.UUID) then traded = true end
                    until traded or os.clock() - st > 5
                    
                    if traded then
                        tradeCount += 1
                        tradedCount += 1
                        acc += val
                        Lexs(string.format("Trade Sent: %s (%d$) - Progress: %d/%d", item.Name, val, tradedCount, targetQuantity))
                        task.wait(tradeDelay)
                    else
                        Lexs("Lag/Failed - Item tidak terkirim.")
                        task.wait(1)
                    end
                else
                    task.wait(1)
                end
            else
                Lexs("Stok Habis - Tidak ada item sesuai filter.")
                break
            end
            task.wait(0.1)
        end
        
        autoTradeState = false
        Lexs("Auto Trade Stopped")
    end)
end

-- Auto Accept Toggle
x9:AddToggle({
    Title = "Auto Accept Trade",
    Description = "Otomatis menerima semua trade masuk.",
    Default = false,
    Callback = function(s)
        autoAcceptState = s
        Lexs(s and "Auto Accept ON - Siap menerima trade." or "Auto Accept OFF")
    end
})

-- Player Dropdown
local playerList = {}
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        table.insert(playerList, p.Name)
    end
end

local PlayerDropdown = x9:AddDropdown({
    Title = "Select Target Player",
    Options = playerList,
    Default = nil,
    Callback = function(n)
        local p = Players:FindFirstChild(n)
        if p then
            selectedTradeTargetId = p.UserId
            Lexs("Target Set: " .. p.Name)
        else
            selectedTradeTargetId = nil
        end
    end
})

-- Refresh Button
x9:AddButton({
    Title = "Refresh Players",
    Description = "Update list players",
    Callback = function()
        local l = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer then table.insert(l, p.Name) end
        end
        PlayerDropdown:SetValues(l)
        Lexs("List Updated - " .. #l .. " players found.")
    end
})

-- Rarity Filter
x9:AddDropdown({
    Title = "Filter Rarity (Optional)",
    Options = {"Common","Uncommon","Rare","Epic","Legendary","Mythic","SECRET","Trophy","Collectible","DEV"},
    Default = nil,
    Callback = function(r) selectedTradeRarity = r end
})

-- Mutation Filter
x9:AddDropdown({
    Title = "Filter Mutation (Optional)",
    Options = {"All Mutations","No Mutation","Shiny","Albino","Sandy","Noob","Moon Fragment","Festive","Disco","1x1x1x1","Bloodmoon","Color Burn","Corrupt","Fairy Dust","Frozen","Galaxy","Gemstone","Ghost","Gold","Holographic","Lightning","Midnight","Radioactive","Stone"},
    Default = nil,
    Callback = function(m)
        if m == "All Mutations" or m == "No Mutation" then
            selectedMutation = ""
        else
            selectedMutation = m
        end
    end
})

-- Options Toggles
x9:AddToggle({
    Title = "Hold Favorite Items",
    Description = "Jangan trade item yang di-Favorite.",
    Default = false,
    Callback = function(s) tradeHoldFavorite = s end
})

x9:AddToggle({
    Title = "Hide Favorited in Dropdown",
    Description = "Sembunyikan item favorit saat scan.",
    Default = false,
    Callback = function(s) hideFavoriteInDropdown = s end
})

x9:AddToggle({
    Title = "Group Mutations",
    Description = "Gabung semua mutasi dalam satu item.",
    Default = false,
    Callback = function(s) groupMutationsInDropdown = s end
})

-- Scan System
local tradeDropdown
local function ScanBackpackItems()
    local items = GetInventoryForScan()
    
    if groupMutationsInDropdown then
        local itemTotals = {}
        local favTotals = {}
        for _, item in ipairs(items) do
            local name = item.Name
            local isFav = item.IsFavorite
            itemTotals[name] = (itemTotals[name] or 0) + 1
            if isFav then favTotals[name] = (favTotals[name] or 0) + 1 end
        end
        
        local itemList = {}
        for itemName, total in pairs(itemTotals) do
            local favCount = favTotals[itemName] or 0
            local displayName = itemName.." (x"..total
            if favCount > 0 then
                displayName = displayName.." â­"
            end
            displayName = displayName..")"
            table.insert(itemList, displayName)
        end
        table.sort(itemList)
        return itemList
    else
        local itemDetails = {}
        for _, item in ipairs(items) do
            local name = item.Name
            local mutation = item.Mutation
            local isFav = item.IsFavorite
            if not itemDetails[name] then itemDetails[name] = {} end
            if not itemDetails[name][mutation] then itemDetails[name][mutation] = {total=0, fav=0} end
            itemDetails[name][mutation].total = itemDetails[name][mutation].total + 1
            if isFav then itemDetails[name][mutation].fav = itemDetails[name][mutation].fav + 1 end
        end
        
        local itemList = {}
        for itemName, mutations in pairs(itemDetails) do
            for mutName, data in pairs(mutations) do
                local displayName = itemName
                if mutName ~= "No Mutation" then
                    displayName = displayName.." ("..mutName.." x"..data.total
                else
                    displayName = displayName.." (x"..data.total
                end
                if data.fav > 0 then
                    displayName = displayName.." â­"
                end
                displayName = displayName..")"
                table.insert(itemList, displayName)
            end
        end
        table.sort(itemList)
        return itemList
    end
end

-- Scan Button
x9:AddButton({
    Title = "Scan Backpack",
    Description = "Scan inventory for items",
    Callback = function()
        local scanned = ScanBackpackItems()
        if #scanned > 0 then
            tradeDropdown:SetValues(scanned)
            Lexs("Scan Complete - " .. #scanned .. " item variations found")
        else
            tradeDropdown:SetValues({"No items found"})
            Lexs("Empty - No items matching filters")
        end
    end
})

-- Item Dropdown
tradeDropdown = x9:AddDropdown({
    Title = "Select Item from Backpack",
    Options = {"Click Scan Backpack first"},
    Default = nil,
    Callback = function(n)
        if n and n ~= "" then
            local itemNameOnly = n:match("^(.+) %(")
            if itemNameOnly then
                itemNameOnly = itemNameOnly:gsub(" %s+$", "")
                selectedTradeItemName = itemNameOnly
            end
        end
    end
})

-- Quantity Input
x9:AddInput({
    Title = "Quantity to Trade",
    Placeholder = "1",
    Default = "1",
    Numeric = true,
    Callback = function(v) 
        tradeQuantity = tonumber(v) or 1 
        Lexs("Quantity set to: " .. tradeQuantity)
    end
})

-- Stop at Coins Input
x9:AddInput({
    Title = "Stop at Coin Value",
    Placeholder = "0",
    Default = "0",
    Numeric = true,
    Callback = function(v)
        tradeStopAtCoins = tonumber(v) or 0
        isTradeByCoinActive = tradeStopAtCoins > 0
        Lexs(isTradeByCoinActive and "Stop at coins: " .. tradeStopAtCoins or "Coin limit disabled")
    end
})

-- Trade Delay Slider
x9:AddSlider({
    Title = "Trade Delay",
    Min = 0.5,
    Max = 5,
    Default = 1,
    Increment = 0.1,
    Callback = function(v) 
        tradeDelay = v
        Lexs("Trade delay set to: " .. v .. "s")
    end
})

-- Start Toggle
x9:AddToggle({
    Title = "Enable Auto Trade",
    Default = false,
    Callback = function(s)
        autoTradeState = s
        if s then
            if not selectedTradeTargetId then
                Lexs("Error: Target Player belum dipilih!")
                return false
            end
            RunAutoTradeLoop()
        else
            if autoTradeThread then task.cancel(autoTradeThread) end
            Lexs("Auto Trade Stopped")
        end
    end
})



x10 = Tabs.Ench:AddSection("Auto Enchant")

local RepStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplionClient = require(RepStorage:WaitForChild("Packages"):WaitForChild("Replion")).Client
local ItemUtility = require(RepStorage:WaitForChild("Shared"):WaitForChild("ItemUtility"))
local RunService = game:GetService("RunService")

local RPath = {"Packages", "_Index", "sleitnick_net@0.2.0", "net"}
local function GetRemote(p, n)
    local c = RepStorage
    for _, k in ipairs(p) do
        c = c:WaitForChild(k, 5)
        if not c then return nil end
    end
    return c:FindFirstChild(n)
end
local RE_EquipItem = GetRemote(RPath, "RE/EquipItem")
local RE_UnequipItem = GetRemote(RPath, "RE/UnequipItem")
local RE_EquipToolFromHotbar = GetRemote(RPath, "RE/EquipToolFromHotbar")
local RE_ActivateEnchantingAltar = GetRemote(RPath, "RE/ActivateEnchantingAltar")

local ENCHANT_ALTAR_POS = Vector3.new(3236.441, -1302.855, 1397.91)
local ENCHANT_ALTAR_LOOK = Vector3.new(-0.954, 0, 0.299)
local ENCHANT_STONE_ID = 10
local EVOLVED_ENCHANT_STONE_ID = 558
local ENCHANT_MAPPING = {
    ["Glistening I"] = 1,
    ["Reeler I"] = 2,
    ["Reeler II"] = 21,
    ["Big Hunter I"] = 3,
    ["Gold Digger I"] = 4,
    ["Leprechaun I"] = 5,
    ["Leprechaun II"] = 6,
    ["Mutation Hunter I"] = 7,
    ["Mutation Hunter II"] = 14,
    ["Mutation Hunter III"] = 22,
    ["Stargazer I"] = 8,
    ["Stargazer II"] = 17,
    ["Empowered I"] = 9,
    ["XPerienced"] = 10,
    ["Stormhunter I"] = 11,
    ["Stormhunter II"] = 19,
    ["Cursed I"] = 12,
    ["Prismatic I"] = 13,
    ["Perfection"] = 15,
    ["SECRET Hunter"] = 16,
    ["Fairy Hunter"] = 18,
    ["Shark Hunter"] = 20
}
local ENCHANT_ROD_LIST = {
    {Name="Luck Rod", ID=79},
    {Name="Carbon Rod", ID=76},
    {Name="Grass Rod", ID=85},
    {Name="Demascus Rod", ID=77},
    {Name="Ice Rod", ID=78},
    {Name="Lucky Rod", ID=4},
    {Name="Midnight Rod", ID=80},
    {Name="Steampunk Rod", ID=6},
    {Name="Chrome Rod", ID=7},
    {Name="Flourescent Rod", ID=255},
    {Name="Astral Rod", ID=5},
    {Name="Ares Rod", ID=126},
    {Name="Angler Rod", ID=168},
    {Name="Ghostfin Rod", ID=169},
    {Name="Element Rod", ID=257},
    {Name="Hazmat Rod", ID=256},
    {Name="Bamboo Rod", ID=258},
    {Name="Diamond Rod", ID=559}
}

local autoEnchantState = false
local autoEnchantThread = nil
local selectedRodUUID = nil
local selectedEnchantNames = {}
local selectedStoneType = "Enchant Stone"

local function TeleportToLookAt(p, l)
    local h = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if h then
        h.CFrame = CFrame.new(p, p + l) * CFrame.new(0, 0.5, 0)
    end
end

local function GetEnchantNamesList()
    local t = {}
    for n in pairs(ENCHANT_MAPPING) do
        table.insert(t, n)
    end
    table.sort(t)
    return t
end

local function GetHardcodedRodNames()
    local t = {}
    for _, v in ipairs(ENCHANT_ROD_LIST) do
        table.insert(t, v.Name)
    end
    return t
end

local function GetPlayerDataReplion()
    local s, r = pcall(function() return ReplionClient:WaitReplion("Data") end)
    return s and r or nil
end

local function GetUUIDByRodID(id)
    local r = GetPlayerDataReplion()
    if not r then return nil end
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if not s or not i or not i["Fishing Rods"] then return nil end
    for _, rod in ipairs(i["Fishing Rods"]) do
        if tonumber(rod.Id) == id then return rod.UUID end
    end
    return nil
end

local function GetStoneUUID(stoneType)
    local targetId = stoneType == "Evolved Enchant Stone" and EVOLVED_ENCHANT_STONE_ID or ENCHANT_STONE_ID
    local r = GetPlayerDataReplion()
    if not r then return nil end
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if s and i.Items then
        for _, it in ipairs(i.Items) do
            if tonumber(it.Id) == targetId and it.UUID then
                local itemData = ItemUtility:GetItemData(it.Id)
                if itemData and itemData.Data then
                    local typeName = itemData.Data.Type
                    if typeName then return it.UUID, typeName end
                end
                return it.UUID, "Enchant Stones"
            end
        end
    end
    return nil
end

local function CheckIfEnchantReached(uuid)
    local r = GetPlayerDataReplion()
    local rods = r:GetExpect("Inventory")["Fishing Rods"] or {}
    local trg = nil
    for _, rod in ipairs(rods) do
        if rod.UUID == uuid then trg = rod break end
    end
    if not trg then return true end
    local eid = trg.Metadata and trg.Metadata.EnchantId
    if not eid then return false end
    for k, v in pairs(selectedEnchantNames) do
        local name = (type(k) == "number") and v or k
        if ENCHANT_MAPPING[name] == eid then return true end
    end
    return false
end

local function UnequipAllEquippedItems()
    local r = GetPlayerDataReplion()
    local e = r:GetExpect("EquippedItems") or {}
    for _, u in ipairs(e) do
        pcall(function() RE_UnequipItem:FireServer(u) end)
        task.wait(0.05)
    end
end

local function RunAutoEnchantLoop(uuid, stoneType)
    if autoEnchantThread then task.cancel(autoEnchantThread) end
    autoEnchantThread = task.spawn(function()
        UnequipAllEquippedItems()
        task.wait(0.5)
        TeleportToLookAt(ENCHANT_ALTAR_POS, ENCHANT_ALTAR_LOOK)
        task.wait(1.5)
        Lexs("Enchant Started: Mulai rolling dengan "..stoneType.."...")
        
        while autoEnchantState do
            if CheckIfEnchantReached(uuid) then
                Lexs("Success! Target Enchant didapatkan.")
                break
            end
            
            local stone, stoneCategory = GetStoneUUID(stoneType)
            if not stone then
                Lexs("Stone Habis! "..stoneType.." sudah habis.")
                break
            end
            
            pcall(function() RE_EquipItem:FireServer(uuid, "Fishing Rods") end)
            task.wait(0.2)
            pcall(function() RE_EquipItem:FireServer(stone, stoneCategory or "Enchant Stones") end)
            task.wait(0.2)
            pcall(function() RE_EquipToolFromHotbar:FireServer(2) end)
            task.wait(0.3)
            pcall(function() RE_ActivateEnchantingAltar:FireServer() end)
            task.wait(1.5)
            pcall(function() RE_EquipToolFromHotbar:FireServer(0) end)
            task.wait(0.5)
        end
        
        autoEnchantState = false
        Lexs("Auto Enchant Stopped")
    end)
end

local RodDropdown = x10:AddDropdown({
    Title = "Select Rod to Enchant",
    Description = "Pilih Rod yang ada di inventory kamu.",
    Options = GetHardcodedRodNames(),
    Callback = function(n)
        selectedRodUUID = nil
        for _, v in ipairs(ENCHANT_ROD_LIST) do
            if v.Name == n then
                local u = GetUUIDByRodID(v.ID)
                if u then
                    selectedRodUUID = u
                    Lexs("Rod Selected: UUID: "..u:sub(1,8).."...")
                else
                    Lexs("Missing: "..n.." tidak ditemukan di tas.")
                end
                break
            end
        end
    end
})

x10:AddDropdown({
    Title = "Select Stone Type",
    Description = "Pilih jenis stone untuk enchant.",
    Options = {"Enchant Stone", "Evolved Enchant Stone"},
    Default = "Enchant Stone",
    Callback = function(v) selectedStoneType = v end
})

x10:AddButton({
    Title = "Re-Check Rod UUID",
    Description = "Klik ini jika kamu baru beli rod tapi dropdown error.",
    Callback = function()
        local n = RodDropdown.Value
        if n then
            for _, v in ipairs(ENCHANT_ROD_LIST) do
                if v.Name == n then
                    local u = GetUUIDByRodID(v.ID)
                    if u then
                        selectedRodUUID = u
                        Lexs("Updated: UUID Rod diperbarui.")
                    else
                        selectedRodUUID = nil
                        Lexs("Error: Rod hilang dari inventory.")
                    end
                    break
                end
            end
        else
            Lexs("Info: Pilih Rod di dropdown dulu.")
        end
    end
})

x10:AddDropdown({
    Title = "Target Enchants",
    Description = "Berhenti jika mendapatkan salah satu dari ini.",
    Options = GetEnchantNamesList(),
    Multi = true,
    Callback = function(n) selectedEnchantNames = n or {} end
})

x10:AddToggle({
    Title = "Enable Auto Enchant",
    Default = false,
    Callback = function(s)
        autoEnchantState = s
        if s then
            if not selectedRodUUID then
                Lexs("Error: Pilih Rod yang valid dulu.")
                return
            end
            
            local hasEnchant = false
            if type(selectedEnchantNames) == "table" then
                for k, v in pairs(selectedEnchantNames) do
                    if v then hasEnchant = true break end
                end
            elseif type(selectedEnchantNames) == "string" and selectedEnchantNames ~= "" then
                hasEnchant = true
                selectedEnchantNames = {selectedEnchantNames}
            end

            if not hasEnchant then
                Lexs("Error: Pilih minimal 1 target enchant.")
                return
            end
            
            RunAutoEnchantLoop(selectedRodUUID, selectedStoneType)
        else
            if autoEnchantThread then
                task.cancel(autoEnchantThread)
                autoEnchantThread = nil
            end
            Lexs("Stopped: Auto Enchant stopped.")
        end
    end
})


x11 = Tabs.Totem:AddSection("Auto Totem")

local totemStatusParagraph = x11:AddParagraph({
    Title = "Totem Status",
    Content = "Waiting..."
})

local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local TOTEM_DATA = {
    ["Luck Totem"] = {Id = 1, Duration = 3601},
    ["Mutation Totem"] = {Id = 2, Duration = 3601},
    ["Shiny Totem"] = {Id = 3, Duration = 3601}
}

local TOTEM_NAMES = {"Luck Totem", "Mutation Totem", "Shiny Totem"}
local selectedTotemName = "Luck Totem"
local currentTotemExpiry = 0
local AUTO_TOTEM_ACTIVE = false
local AUTO_TOTEM_THREAD = nil

local PlayerDataReplion = nil
local function GetPlayerData()
    if PlayerDataReplion then return PlayerDataReplion end
    local success, result = pcall(function()
        local Replion = RS:WaitForChild("Packages", 10):WaitForChild("Replion", 10)
        return require(Replion).Client:WaitReplion("Data", 5)
    end)
    if success and result then
        PlayerDataReplion = result
        return result
    end
    return nil
end

local function GetRemoteSmart(name)
    local packages = RS:WaitForChild("Packages", 10)
    local index = packages and packages:WaitForChild("_Index", 10)
    if index then
        for _, child in ipairs(index:GetChildren()) do
            if child.Name:find("net@") then
                local net = child:FindFirstChild("net")
                if net then
                    local remote = net:FindFirstChild(name)
                    if remote then return remote end
                end
            end
        end
    end
    return nil
end

local RE_SpawnTotem = nil
local RE_EquipToolFromHotbar = nil

task.spawn(function()
    while not RE_SpawnTotem do
        RE_SpawnTotem = GetRemoteSmart("RE/SpawnTotem")
        if not RE_SpawnTotem then task.wait(1) end
    end
end)

task.spawn(function()
    while not RE_EquipToolFromHotbar do
        RE_EquipToolFromHotbar = GetRemoteSmart("RE/EquipToolFromHotbar")
        if not RE_EquipToolFromHotbar then task.wait(1) end
    end
end)

local function GetTotemUUID(name)
    local replion = GetPlayerData()
    if not replion then return nil end
    
    local success, data = pcall(function()
        return replion:GetExpect("Inventory")
    end)
    
    if success and data and data.Totems then
        for _, item in ipairs(data.Totems) do
            if tonumber(item.Id) == TOTEM_DATA[name].Id and (item.Count or 1) >= 1 then
                return item.UUID
            end
        end
    end
    return nil
end

local function RunAutoTotemLoop()
    if AUTO_TOTEM_THREAD then
        task.cancel(AUTO_TOTEM_THREAD)
    end
    
    AUTO_TOTEM_THREAD = task.spawn(function()
        while AUTO_TOTEM_ACTIVE and task.wait(1) do
            local timeLeft = currentTotemExpiry - os.time()
            
            if timeLeft > 0 then
                local minutes = math.floor((timeLeft % 3600) / 60)
                local seconds = timeLeft % 60
                pcall(function()
                    totemStatusParagraph:SetContent(string.format("Next spawn: %02d:%02d", minutes, seconds))
                end)
            else
                pcall(function()
                    totemStatusParagraph:SetContent("Spawning totem...")
                end)
                
                if not GetPlayerData() then
                    Lexs("Auto Totem: Waiting for data...")
                    task.wait(5)
                    continue
                end
                
                if not RE_SpawnTotem then
                    Lexs("Auto Totem: Waiting for RE_SpawnTotem...")
                    RE_SpawnTotem = GetRemoteSmart("RE/SpawnTotem")
                    task.wait(5)
                    continue
                end
                
                local uuid = GetTotemUUID(selectedTotemName)
                
                if uuid then
                    local success, err = pcall(function()
                        RE_SpawnTotem:FireServer(uuid)
                    end)
                    
                    if success then
                        currentTotemExpiry = os.time() + TOTEM_DATA[selectedTotemName].Duration
                        Lexs("Auto Totem: "..selectedTotemName.." spawned!")
                        pcall(function()
                            totemStatusParagraph:SetContent(selectedTotemName.." active!")
                        end)
                        
                        if RE_EquipToolFromHotbar then
                            for i = 1, 3 do
                                task.wait(0.2)
                                pcall(function()
                                    RE_EquipToolFromHotbar:FireServer(1)
                                end)
                            end
                        end
                    else
                        Lexs("Auto Totem Error: " .. tostring(err))
                        pcall(function()
                            totemStatusParagraph:SetContent("Error spawning totem")
                        end)
                    end
                else
                    Lexs("Auto Totem: No " .. selectedTotemName .. " found in inventory")
                    pcall(function()
                        totemStatusParagraph:SetContent("No "..selectedTotemName.." in inventory")
                    end)
                    task.wait(60)
                end
            end
        end
    end)
end

x11:AddDropdown({
    Title = "Pilih Totem",
    Options = TOTEM_NAMES,
    Default = "Luck Totem",
    Callback = function(value)
        selectedTotemName = value
        currentTotemExpiry = 0
        Lexs("Totem changed to: " .. value)
    end
})

x11:AddToggle({
    Title = "Auto Totem (Single)",
    Default = false,
    Callback = function(state)
        AUTO_TOTEM_ACTIVE = state
        
        if state then
            Lexs("Auto Totem: Starting...")
            RunAutoTotemLoop()
        else
            if AUTO_TOTEM_THREAD then
                task.cancel(AUTO_TOTEM_THREAD)
                AUTO_TOTEM_THREAD = nil
            end
            Lexs("Auto Totem: Stopped")
        end
    end
})


x12 = Tabs.Quest:AddSection("Deep Sea Quest")

local DeepSeaParagraph = x12:AddParagraph({
    Title = "Deep Sea Monitor",
    Content = "Click toggle to start..."
})

local runningDeepSea = false
local deepSeaThread = nil

local TREASURE_ROOM_CF = CFrame.new(-3650.4873, -269.269318, -1652.68323, -0.147814155, 0, -0.989015162, 0, 1, 0, 0.989015162, 0, -0.147814155)
local SISYPHUS_CF = CFrame.new(-3737, -136, -881)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Replion = require(ReplicatedStorage.Packages.Replion)
local ClientData = nil

task.spawn(function()
    ClientData = Replion.Client:WaitReplion("Data")
end)

local function GetDeepSeaStatus()
    if not ClientData then 
        return {QuestCompleted = false, QuestActive = false, Progress = nil, HasGhostfinRod = false}
    end
    
    local result = {QuestCompleted = false, QuestActive = false, Progress = nil, HasGhostfinRod = false}
    
    local completedQuests = ClientData:Get({"CompletedQuests"}) or {}
    for _, questName in ipairs(completedQuests) do
        if questName == "Deep Sea Quest" then
            result.QuestCompleted = true
        end
    end
    
    local inventory = ClientData:Get({"Inventory"})
    if inventory and inventory["Fishing Rods"] then
        for _, rod in ipairs(inventory["Fishing Rods"]) do
            if rod.Id == 169 then
                result.HasGhostfinRod = true
                break
            end
        end
    end
    
    if not result.QuestCompleted then
        local questData = ClientData:Get({"Quests", "Mainline", "Deep Sea Quest"})
        if questData then
            result.QuestActive = true
            result.Progress = {
                Q1 = {Progress = 0, Done = false},
                Q2 = {Progress = 0, Done = false},
                Q3 = {Progress = 0, Done = false},
                Q4 = {Progress = 0, Done = false},
                TotalPercent = 0,
                AllDone = false
            }
            
            for objId, objData in pairs(questData.Objectives) do
                local numId = tonumber(objId)
                local progress = objData.Progress or 0
                
                if numId == 1 then
                    result.Progress.Q1.Progress = progress
                    result.Progress.Q1.Done = progress >= 300
                elseif numId == 2 then
                    result.Progress.Q2.Progress = progress
                    result.Progress.Q2.Done = progress >= 3
                elseif numId == 3 then
                    result.Progress.Q3.Progress = progress
                    result.Progress.Q3.Done = progress >= 1
                elseif numId == 4 then
                    result.Progress.Q4.Progress = progress
                    result.Progress.Q4.Done = progress >= 1000000
                end
            end
            
            local completedCount = 0
            local totalObjectives = 4
            if result.Progress.Q1.Done then completedCount = completedCount + 1 end
            if result.Progress.Q2.Done then completedCount = completedCount + 1 end
            if result.Progress.Q3.Done then completedCount = completedCount + 1 end
            if result.Progress.Q4.Done then completedCount = completedCount + 1 end
            
            result.Progress.AllDone = (completedCount == totalObjectives)
            result.Progress.TotalPercent = math.floor((completedCount / totalObjectives) * 100)
        end
    end
    
    return result
end

local function TeleportTo(cf)
    local p = game.Players.LocalPlayer
    local c = p.Character
    local h = c and c:FindFirstChild("HumanoidRootPart")
    if h then
        task.wait(0.1)
        h.CFrame = cf
        task.wait(0.3)
    end
end

local function IsFar(cf, dist)
    local c = game.Players.LocalPlayer.Character
    local h = c and c:FindFirstChild("HumanoidRootPart")
    return not h or (h.Position - cf.Position).Magnitude > dist
end

local function RunDeepSea()
    if deepSeaThread then
        task.cancel(deepSeaThread)
    end
    
    deepSeaThread = task.spawn(function()
        local lastNotif = 0
        
        while runningDeepSea do
            local status = GetDeepSeaStatus()
            
            -- Update paragraph with progress
            if status.QuestActive and status.Progress then
                local progressText = string.format(
                    "Progress: %d%% | R/E: %d/300 | M: %d/3 | S: %d/1 | Coins: %s/1M",
                    status.Progress.TotalPercent,
                    status.Progress.Q1.Progress,
                    status.Progress.Q2.Progress,
                    status.Progress.Q3.Progress,
                    tostring(status.Progress.Q4.Progress)
                )
                pcall(function()
                    DeepSeaParagraph:SetContent(progressText)
                end)
            end
            
            -- Check completion
            if status.QuestCompleted then
                Lexs("Deep Sea Quest completed! Ghostfin Rod " .. (status.HasGhostfinRod and "obtained" or "ready to claim"))
                pcall(function()
                    DeepSeaParagraph:SetContent("Quest completed!")
                end)
                runningDeepSea = false
                break
            elseif not status.QuestActive then
                if os.time() - lastNotif > 30 then
                    Lexs("Deep Sea: Quest not active. Go to Deep Sea area to start.")
                    lastNotif = os.time()
                end
            elseif status.QuestActive and status.Progress.AllDone then
                Lexs("Deep Sea: All objectives done! Return to altar to claim.")
                pcall(function()
                    DeepSeaParagraph:SetContent("Ready to claim! Go to altar.")
                end)
                runningDeepSea = false
                break
            end
            
            -- Teleport logic
            if status.QuestActive and status.Progress then
                local targetCF = nil
                
                if not status.Progress.Q1.Done then
                    targetCF = TREASURE_ROOM_CF
                elseif not status.Progress.Q2.Done or not status.Progress.Q3.Done then
                    targetCF = SISYPHUS_CF
                elseif not status.Progress.Q4.Done then
                    targetCF = SISYPHUS_CF
                end
                
                if targetCF and IsFar(targetCF, 20) then
                    TeleportTo(targetCF)
                    task.wait(1.5)
                end
            end
            
            task.wait(1)
        end
        
        if not runningDeepSea then
            pcall(function()
                DeepSeaParagraph:SetContent("Stopped")
            end)
        end
        
        deepSeaThread = nil
    end)
end

x12:AddToggle({
    Title = "Auto Complete Deep Sea",
    Description = "One-time quest: Farm Ghostfin Rod",
    Default = false,
    Callback = function(s)
        runningDeepSea = s
        
        if s then
            Lexs("Deep Sea: Checking quest status...")
            task.wait(0.5)
            local status = GetDeepSeaStatus()
            
            if status.QuestCompleted then
                Lexs("Deep Sea Quest already completed!")
                pcall(function()
                    DeepSeaParagraph:SetContent("Quest already completed")
                end)
                runningDeepSea = false
                return
            elseif status.QuestActive and status.Progress and status.Progress.AllDone then
                Lexs("Deep Sea: All objectives done! Return to altar.")
                pcall(function()
                    DeepSeaParagraph:SetContent("Ready to claim")
                end)
                runningDeepSea = false
                return
            else
                Lexs("Deep Sea: Starting automation...")
                RunDeepSea()
            end
        else
            if deepSeaThread then
                task.cancel(deepSeaThread)
                deepSeaThread = nil
            end
            Lexs("Deep Sea: Stopped")
            pcall(function()
                DeepSeaParagraph:SetContent("Stopped")
            end)
        end
    end
})


x12 = Tabs.Quest:AddSection("Element Quest")

local ElementParagraph = x12:AddParagraph({
    Title = "Element Quest Monitor",
    Content = "Click toggle to start..."
})

local runningElement = false
local elementThread = nil

local ALTAR_CF = CFrame.new(1479.587, 128.295, -604.224)
local JUNGLE_CF = CFrame.new(1535.639, 3.159, -193.352, 0.505, -0.000, 0.863, 0.000, 1.000, 0.000, -0.863, 0.000, 0.505)
local TEMPLE_CF = CFrame.new(1461.815, -22.125, -670.234, -0.990, -0.000, 0.143, 0.000, 1.000, 0.000, -0.143, 0.000, -0.990)

local function GetElementQuestStatus()
    if not ClientData then
        return {QuestCompleted = false, QuestActive = false, DeepSeaCompleted = false, HasGhostfinRod = false, Progress = nil, CanStartElement = false}
    end
    
    local result = {QuestCompleted = false, QuestActive = false, DeepSeaCompleted = false, HasGhostfinRod = false, Progress = nil, CanStartElement = false}
    
    local completedQuests = ClientData:Get({"CompletedQuests"}) or {}
    for _, questName in ipairs(completedQuests) do
        if questName == "Deep Sea Quest" then
            result.DeepSeaCompleted = true
        end
        if questName == "Element Quest" then
            result.QuestCompleted = true
        end
    end
    
    local inventory = ClientData:Get({"Inventory"})
    if inventory and inventory["Fishing Rods"] then
        for _, rod in ipairs(inventory["Fishing Rods"]) do
            if rod.Id == 169 then
                result.HasGhostfinRod = true
                break
            end
        end
    end
    
    result.CanStartElement = result.DeepSeaCompleted or result.HasGhostfinRod
    
    if not result.QuestCompleted then
        local questData = ClientData:Get({"Quests", "Mainline", "Element Quest"})
        if questData then
            result.QuestActive = true
            result.Progress = {
                Q1 = {Done = true, Text = "Ghostfin Rod: Done"},
                Q2 = {Progress = 0, Done = false, Text = "Jungle Secret: Not Done"},
                Q3 = {Progress = 0, Done = false, Text = "Temple Secret: Not Done"},
                Q4 = {Progress = 0, Done = false, Text = "Transcended Stones: 0/3"},
                TotalPercent = 0,
                AllDone = false
            }
            
            for objId, objData in pairs(questData.Objectives) do
                local numId = tonumber(objId)
                local progress = objData.Progress or 0
                
                if numId == 2 then
                    result.Progress.Q2.Progress = progress
                    result.Progress.Q2.Done = progress >= 1
                    result.Progress.Q2.Text = result.Progress.Q2.Done and "Jungle Secret: Done" or "Jungle Secret: Not Done"
                elseif numId == 3 then
                    result.Progress.Q3.Progress = progress
                    result.Progress.Q3.Done = progress >= 1
                    result.Progress.Q3.Text = result.Progress.Q3.Done and "Temple Secret: Done" or "Temple Secret: Not Done"
                elseif numId == 4 then
                    result.Progress.Q4.Progress = progress
                    result.Progress.Q4.Done = progress >= 3
                    result.Progress.Q4.Text = string.format("Transcended Stones: %d/3", progress)
                end
            end
            
            result.Progress.Q1.Done = result.CanStartElement
            result.Progress.Q1.Text = result.CanStartElement and "Ghostfin Rod: Done" or "Ghostfin Rod: Not Done"
            
            local completedCount = 0
            if result.Progress.Q1.Done then completedCount = completedCount + 1 end
            if result.Progress.Q2.Done then completedCount = completedCount + 1 end
            if result.Progress.Q3.Done then completedCount = completedCount + 1 end
            if result.Progress.Q4.Done then completedCount = completedCount + 1 end
            
            result.Progress.AllDone = (completedCount == 4)
            result.Progress.TotalPercent = math.floor((completedCount / 4) * 100)
        end
    end
    
    return result
end

local function RunElementQuest()
    if elementThread then
        task.cancel(elementThread)
    end
    
    elementThread = task.spawn(function()
        local lastNotif = 0
        
        while runningElement do
            local status = GetElementQuestStatus()
            
            -- Update paragraph with progress
            if status.QuestActive and status.Progress then
                local progressText = string.format(
                    "Progress: %d%% | Jungle: %s | Temple: %s | Stones: %d/3",
                    status.Progress.TotalPercent,
                    status.Progress.Q2.Done and "Done" or "Not Done",
                    status.Progress.Q3.Done and "Done" or "Not Done",
                    status.Progress.Q4.Progress
                )
                pcall(function()
                    ElementParagraph:SetContent(progressText)
                end)
            end
            
            -- Check completion
            if status.QuestCompleted then
                Lexs("Element Quest completed! Element Rod obtained.")
                pcall(function()
                    ElementParagraph:SetContent("Quest completed!")
                end)
                runningElement = false
                break
            elseif not status.CanStartElement then
                if os.time() - lastNotif > 30 then
                    Lexs("Element Quest: Need to complete Deep Sea Quest first or have Ghostfin Rod")
                    lastNotif = os.time()
                end
                runningElement = false
                break
            elseif not status.QuestActive then
                if os.time() - lastNotif > 15 then
                    Lexs("Element Quest: Going to altar to start quest...")
                    lastNotif = os.time()
                end
                
                if IsFar(ALTAR_CF, 20) then
                    TeleportTo(ALTAR_CF)
                    task.wait(2)
                end
                task.wait(2)
            elseif status.QuestActive and status.Progress.AllDone then
                Lexs("Element Quest: All objectives done! Return to altar to claim Element Rod.")
                pcall(function()
                    ElementParagraph:SetContent("Ready to claim! Go to altar.")
                end)
                runningElement = false
                break
            end
            
            -- Teleport logic
            if status.QuestActive and status.Progress then
                local targetCF = nil
                
                if not status.Progress.Q2.Done then
                    targetCF = JUNGLE_CF
                elseif not status.Progress.Q3.Done then
                    targetCF = TEMPLE_CF
                elseif not status.Progress.Q4.Done then
                    targetCF = ALTAR_CF
                end
                
                if targetCF and IsFar(targetCF, 20) then
                    TeleportTo(targetCF)
                    task.wait(1.5)
                end
            end
            
            task.wait(2)
        end
        
        if not runningElement then
            pcall(function()
                ElementParagraph:SetContent("Stopped")
            end)
        end
        
        elementThread = nil
    end)
end

x12:AddToggle({
    Title = "Auto Track Element Quest",
    Description = "Requires: Deep Sea completed OR Ghostfin Rod",
    Default = false,
    Callback = function(s)
        runningElement = s
        
        if s then
            Lexs("Element Quest: Checking quest status...")
            task.wait(0.5)
            local status = GetElementQuestStatus()
            
            if status.QuestCompleted then
                Lexs("Element Quest already completed!")
                pcall(function()
                    ElementParagraph:SetContent("Quest already completed")
                end)
                runningElement = false
                return
            elseif not status.CanStartElement then
                Lexs(string.format("Element Quest: Can't start | Deep Sea: %s | Ghostfin Rod: %s", 
                    status.DeepSeaCompleted and "Done" or "Not Done",
                    status.HasGhostfinRod and "Have" or "Don't Have"))
                pcall(function()
                    ElementParagraph:SetContent("Need Deep Sea Quest or Ghostfin Rod")
                end)
                runningElement = false
                return
            elseif status.QuestActive and status.Progress and status.Progress.AllDone then
                Lexs("Element Quest: All objectives done! Return to altar.")
                pcall(function()
                    ElementParagraph:SetContent("Ready to claim")
                end)
                runningElement = false
                return
            else
                Lexs("Element Quest: Starting automation...")
                RunElementQuest()
            end
        else
            if elementThread then
                task.cancel(elementThread)
                elementThread = nil
            end
            Lexs("Element Quest: Stopped")
            pcall(function()
                ElementParagraph:SetContent("Stopped")
            end)
        end
    end
})

x12 = Tabs.Quest:AddSection("Diamond Quest")

    local DiamondParagraph = x12:AddParagraph({Title="Diamond Quest Monitor", Content="Initializing...", Icon="gem"})
    
    local runningDiamond = false
    local diamondThread = nil

    -- Constants
    local DIAMOND_ROD_ID = 559
    local ELEMENT_ROD_ID = 257
    local RUBY_ID, LOCHNESS_ID = 243, 228
    
    -- Farm Locations
    local LOCATIONS = {
        CORAL = CFrame.new(-3020, 3, 2260),
        TROPICAL = CFrame.new(-2150, 53, 3672),
        RUBY = CFrame.new(-3595, -279, -1589),
        LOCHNESS = CFrame.new(-712, 6, 707)
    }

    local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)

    local function GetDiamondQuestStatus()
        local result = {
            HasElementRod = false, HasDiamondRod = false, HasDiamondKey = false, 
            InventoryCheck = {HasRuby = false, HasLochness = false}, 
            Progress = {
                Q1={Done=false, Text="Element Rod: Not Done"},
                Q2={Progress=0, Done=false, Text="Coral Secret: 0/1"},
                Q3={Progress=0, Done=false, Text="Tropical Secret: 0/1"},
                Q4={Done=false, Text="Lochness Monster: Not Done"},
                Q5={Done=false, Text="Mutated Ruby: Not Done"},
                Q6={Progress=0, Done=false, Text="Perfect Throws: 0/1000"},
                AllDone=false, TotalPercent=0
            }
        }
        
        if not ClientData then return result end
        
        -- Inventory Check
        local inventory = ClientData:Get({"Inventory"}) or {}
        if inventory["Fishing Rods"] then
            for _, rod in ipairs(inventory["Fishing Rods"]) do
                local id = tonumber(rod.Id)
                if id == ELEMENT_ROD_ID then result.HasElementRod = true
                elseif id == DIAMOND_ROD_ID then result.HasDiamondRod = true end
            end
        end
        if inventory.Items then
            for _, item in ipairs(inventory.Items) do
                local id = tonumber(item.Id)
                if id == RUBY_ID and (item.Metadata and item.Metadata.VariantId == 3) then result.InventoryCheck.HasRuby = true
                elseif id == LOCHNESS_ID then result.InventoryCheck.HasLochness = true end
                
                local d = ItemUtility:GetItemData(item.Id)
                if d and d.Data and d.Data.Name == "Diamond Key" then result.HasDiamondKey = true end
            end
        end

        -- Update Initial States
        if result.HasElementRod then result.Progress.Q1 = {Done=true, Text="Element Rod: Done"} end
        if result.InventoryCheck.HasLochness then result.Progress.Q4 = {Done=true, Text="Lochness Monster: Done"} end
        if result.InventoryCheck.HasRuby then result.Progress.Q5 = {Done=true, Text="Mutated Ruby: Done"} end

        -- Quest Data Check (Main Logic)
        local questData = ClientData:Get({"Quests", "Mainline", "Diamond Researcher"}) -- CORRECT NAME
        if questData and questData.Objectives then
            for _, objData in pairs(questData.Objectives) do
                local numId = tonumber(objData.Id)
                local progress = tonumber(objData.Progress) or 0
                
                if numId == 2 then -- Coral Secret
                    result.Progress.Q2 = {Progress=progress, Done=(progress>=1), Text=(progress>=1 and "Coral Secret: Done" or "Coral Secret: 0/1")}
                elseif numId == 3 then -- Tropical Secret
                    result.Progress.Q3 = {Progress=progress, Done=(progress>=1), Text=(progress>=1 and "Tropical Secret: Done" or "Tropical Secret: 0/1")}
                elseif numId == 6 then -- Perfect Throws
                    result.Progress.Q6 = {Progress=progress, Done=(progress>=1000), Text=string.format("Perfect Throws: %d/1000", progress)}
                end
            end
        end

        -- Calculate Total
        local count = 0
        if result.Progress.Q1.Done then count = count + 1 end
        if result.Progress.Q2.Done then count = count + 1 end
        if result.Progress.Q3.Done then count = count + 1 end
        if result.Progress.Q4.Done then count = count + 1 end
        if result.Progress.Q5.Done then count = count + 1 end
        if result.Progress.Q6.Done then count = count + 1 end
        
        result.Progress.AllDone = (count == 6)
        result.Progress.TotalPercent = math.floor((count / 6) * 100)
        
        return result
    end

    local function ClaimDiamondRod()
        local packages = ReplicatedStorage:WaitForChild("Packages")
        local net = packages:WaitForChild("_Index"):FindFirstChild("sleitnick_net@0.2.0")
        if net then
            local remote = net.net:FindFirstChild("RF/ClaimItem")
            if remote then
                local s, r = pcall(function() return remote:InvokeServer("Diamond Rod") end)
                return s, (s and "Successfully claimed!" or "Failed: " .. tostring(r))
            end
        end
        return false, "Claim remote not found"
    end

    local TURN_IN_CF = CFrame.new(-1772, -223, 23920)

    local function GetRemote(path)
        local curr = ReplicatedStorage
        for _, p in ipairs(path) do
            curr = curr:WaitForChild(p, 5)
            if not curr then return nil end
        end
        return curr
    end

    local RE_UnequipItem = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RE/UnequipItem"})
    local RE_EquipItem = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RE/EquipItem"})
    local RE_DialogueEnded = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RE/DialogueEnded"})

    local function UnequipAllEquippedItems()
        if not ClientData or not RE_UnequipItem then return end
        local r = ClientData:Get({"EquippedItems"}) or {}
        for _, u in ipairs(r) do
            pcall(function() RE_UnequipItem:FireServer(u) end)
            task.wait(0.05)
        end
    end

    local function EquipItem(uuid)
        if not RE_EquipItem then return end
        pcall(function() RE_EquipItem:FireServer(uuid) end)
        task.wait(0.5)
    end

    local function FindItemUUID(itemId)
        local inv = ClientData:Get({"Inventory"})
        if inv and inv.Items then
            for _, item in ipairs(inv.Items) do
                if tonumber(item.Id) == itemId then return item.UUID end
            end
        end
        return nil
    end

    -- Remote Definitions
    local RFC = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RF/ChargeFishingRod"})
    local RFS = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RF/RequestFishingMinigameStarted"})
    local REF = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RE/FishingCompleted"})
    local RFK = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RF/CancelFishingInputs"})
    local RE_EquipToolFromHotbar = GetRemote({"Packages", "_Index", "sleitnick_net@0.2.0", "net", "RE/EquipToolFromHotbar"})

    local function RunDiamondQuest()
        if diamondThread then task.cancel(diamondThread) end
        diamondThread = task.spawn(function()
            local lastDisplayUpdate = 0
            while runningDiamond do
                local status = GetDiamondQuestStatus()
                
                -- UI Update
                if tick() - lastDisplayUpdate > 1 then
                    if status.HasDiamondRod then
                         pcall(function() DiamondParagraph:SetContent("Quest Completed: You already have the Diamond Rod! Automation stopped.") end)
                         runningDiamond = false
                         break
                    elseif not status.HasElementRod then
                         pcall(function() DiamondParagraph:SetContent("Missing Requirement: Need Element Rod (ID: 257) to start.") end)
                         runningDiamond = false
                         break
                    elseif status.Progress.AllDone then
                        if status.HasDiamondKey then
                            pcall(function() DiamondParagraph:SetContent("Diamond Key Found! Executing sequence...") end)
                            
                            -- 1. Cancel Fishing (Safety)
                            pcall(function() DiamondParagraph:SetContent("Safety check: Cancelling fishing inputs...") end)
                            if RFK then for _=1,3 do pcall(function() RFK:InvokeServer() end) task.wait(0.1) end end
                            
                            -- 2. Equip Diamond Key
                            pcall(function() DiamondParagraph:SetContent("Equipping Diamond Key...") end)
                            UnequipAllEquippedItems()
                            local keyUUID = FindItemUUID(574) -- Diamond Key ID
                            if keyUUID then
                                EquipItem(keyUUID)
                                task.wait(0.5)
                            else
                                pcall(function() DiamondParagraph:SetContent("Error: Diamond Key UUID not found!") end)
                                task.wait(2)
                            end

                            -- 3. Teleport to Cellar
                            local CELLAR_CF = CFrame.new(-1761, -223, 23943)
                            if IsFar(CELLAR_CF, 10) then
                                pcall(function() DiamondParagraph:SetContent("Teleporting to Cellar Door...") end)
                                TeleportTo(CELLAR_CF)
                                task.wait(2)
                            else
                                -- 4. Interact (Proximity Prompt)
                                pcall(function() DiamondParagraph:SetContent("Interacting with Door...") end)
                                pcall(function()
                                    for _, v in ipairs(workspace:GetDescendants()) do
                                        if v:IsA("ProximityPrompt") and (v.Parent.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude < 15 then
                                            fireproximityprompt(v)
                                        end
                                    end
                                end)
                                task.wait(2)

                                -- 5. Claim Diamond Rod
                                pcall(function() DiamondParagraph:SetContent("Claiming Diamond Rod...") end)
                                local s, msg = ClaimDiamondRod()
                                pcall(function() DiamondParagraph:SetContent(msg) end)
                                
                                -- 6. Equip Slot 2
                                if s then
                                     task.wait(1)
                                     if RE_EquipToolFromHotbar then
                                         pcall(function() RE_EquipToolFromHotbar:FireServer(2) end)
                                     end
                                     
                                     runningDiamond = false
                                     break 
                                end
                            end
                        else
                            pcall(function() DiamondParagraph:SetContent("Go to Lary: Quest finished! Talk to Lary to get Diamond Key.") end)
                        end
                    else
                        local txt = table.concat({
                            string.format("Progress: %d%%", status.Progress.TotalPercent),
                            status.Progress.Q1.Text, status.Progress.Q2.Text, status.Progress.Q3.Text,
                            status.Progress.Q4.Text, status.Progress.Q5.Text, status.Progress.Q6.Text
                        }, "\n")
                        pcall(function() DiamondParagraph:SetContent(txt) end)
                    end
                    lastDisplayUpdate = tick()
                end

                -- Turn-In Logic
                if runningDiamond and RE_DialogueEnded then
                    -- Turn in Ruby (Q5)
                    if status.InventoryCheck.HasRuby and not status.Progress.Q5.Done then
                         if IsFar(TURN_IN_CF, 10) then
                             pcall(function() DiamondParagraph:SetContent("Teleporting to turn in Mutated Ruby...") end)
                             TeleportTo(TURN_IN_CF)
                             task.wait(2)
                         else
                             pcall(function() DiamondParagraph:SetContent("Equipping Ruby & Turning In...") end)
                             UnequipAllEquippedItems()
                             
                             -- Safety check: Cancel inputs 3x
                             if RFK then
                                 for _ = 1, 3 do pcall(function() RFK:InvokeServer() end) task.wait(0.1) end
                             end
                             
                             local uuid = FindItemUUID(RUBY_ID)
                             if uuid then
                                 EquipItem(uuid)
                                 -- Ruby Sequence: (1,3) then (2,1)
                                 RE_DialogueEnded:FireServer("Diamond Researcher", 1, 3)
                                 task.wait(1)
                                 RE_DialogueEnded:FireServer("Diamond Researcher", 2, 1)
                                 task.wait(2)
                                 
                                 -- Re-equip Rod (Slot 1)
                                 if RE_EquipToolFromHotbar then
                                     pcall(function() RE_EquipToolFromHotbar:FireServer(1) end)
                                     task.wait(0.5)
                                 end
                             end
                         end
                    -- Turn in Lochness (Q4)
                    elseif status.InventoryCheck.HasLochness and not status.Progress.Q4.Done then
                         if IsFar(TURN_IN_CF, 10) then
                             pcall(function() DiamondParagraph:SetContent("Teleporting to turn in Ancient Lochness...") end)
                             TeleportTo(TURN_IN_CF)
                             task.wait(2)
                         else
                             pcall(function() DiamondParagraph:SetContent("Equipping Lochness & Turning In...") end)
                             UnequipAllEquippedItems()
                             
                             -- Safety check: Cancel inputs 3x
                             if RFK then
                                 for _ = 1, 3 do pcall(function() RFK:InvokeServer() end) task.wait(0.1) end
                             end
                             
                             local uuid = FindItemUUID(LOCHNESS_ID)
                             if uuid then
                                 EquipItem(uuid)
                                 -- Lochness Sequence: (1,3) then (2,2)
                                 RE_DialogueEnded:FireServer("Diamond Researcher", 1, 3)
                                 task.wait(1)
                                 RE_DialogueEnded:FireServer("Diamond Researcher", 2, 2)
                                 task.wait(2)
                                 
                                 -- Re-equip Rod (Slot 1)
                                 if RE_EquipToolFromHotbar then
                                     pcall(function() RE_EquipToolFromHotbar:FireServer(1) end)
                                     task.wait(0.5)
                                 end
                             end
                         end
                    end
                end

                -- Auto Farm & Fishing Logic
                if runningDiamond and not status.Progress.AllDone then
                    local target = nil
                    if not status.Progress.Q2.Done then target = LOCATIONS.CORAL
                    elseif not status.Progress.Q3.Done then target = LOCATIONS.TROPICAL
                    elseif not status.Progress.Q4.Done and not status.InventoryCheck.HasLochness then target = LOCATIONS.LOCHNESS
                    elseif not status.Progress.Q5.Done and not status.InventoryCheck.HasRuby then target = LOCATIONS.RUBY
                    elseif not status.Progress.Q6.Done then target = LOCATIONS.TROPICAL end -- Best spot for throws
                    
                    local isTurningIn = false
                    if (status.InventoryCheck.HasRuby and not status.Progress.Q5.Done) or (status.InventoryCheck.HasLochness and not status.Progress.Q4.Done) then
                         isTurningIn = true
                    end

                    -- Movement Logic
                    if target and not isTurningIn then
                         if IsFar(target, 20) then
                              TeleportTo(target)
                              task.wait(1)
                         end
                    end
                    
                    -- Fishing Logic (Anywhere except when turning in)
                    if not isTurningIn then
                         -- At target location (loose check) or just ensuring we are not moving
                         if RFC and RFS and REF and RFK then
                             local CD, FD, KD = 0.45, 0.7, 0.3
                             local function safe(f) task.spawn(function() pcall(f) end) end

                             pcall(function() DiamondParagraph:SetContent("Fishing (Blatant V3 Async) - " .. (target == LOCATIONS.CORAL and "Coral" or target == LOCATIONS.TROPICAL and "Tropical" or "Farm")) end)
                             
                             -- Cast
                             local t = tick()
                             safe(function() RFC:InvokeServer({[1]=t}) end)
                             task.wait(CD)
                             
                             -- Strike
                             local r = tick()
                             safe(function() RFS:InvokeServer(1,0,r) end)
                             
                             -- Double Cast/Strike
                             local t2 = tick()
                             safe(function() RFC:InvokeServer({[1]=t2}) end)
                             task.wait(CD)
                             local r2 = tick()
                             safe(function() RFS:InvokeServer(1,0,r2) end)
                             
                             task.wait(FD) 
                             if not runningDiamond then break end
                             
                             -- Finish
                             safe(function() REF:FireServer() end)
                             
                             task.wait(KD)
                             safe(function() pcall(function() RFK:InvokeServer() end) end)
                             task.wait(0.001)
                        else
                             pcall(function() DiamondParagraph:SetContent("Waiting (Fishing Remotes Missing)...") end)
                             task.wait(1)
                        end
                    end
                end
                
                task.wait(0.1) -- Faster loop for fishing
            end
            diamondThread = nil
        end)
    end

    local DiamondToggle = x12:AddToggle("autoDiamond", {
        Title = "Auto Complete Diamond Quest",
        Description = "Auto farm requirements & objectives",
        Default = false,
        Callback = function(s)
            runningDiamond = s
            if s then
                pcall(function() DiamondParagraph:SetContent("Checking quest status...") end)
                RunDiamondQuest()
            else
                if diamondThread then task.cancel(diamondThread) diamondThread = nil end
                pcall(function() DiamondParagraph:SetContent("Stopped") end)
            end
        end
    })

x12 = Tabs.Quest:AddSection("Auto Quest Dorian")

local dorianRunning = false
local dorianThread = nil

x12:AddToggle({
    Title = "Auto Dorian Quest (Coral)",
    Description = "Start Quest -> Collect 30 Coral -> Finish Quest",
    Default = false,
    Callback = function(s)
        dorianRunning = s
        
        if s then
            dorianThread = task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Net = ReplicatedStorage:WaitForChild("Packages", 10)
                if Net then Net = Net:WaitForChild("_Index", 5) end
                if Net then Net = Net:WaitForChild("sleitnick_net@0.2.0", 5) end
                if Net then Net = Net:WaitForChild("net", 5) end
                
                if not Net then
                    Lexs("Dorian Quest Error: Net remote folder not found!")
                    dorianRunning = false
                    return
                end

                local RE_DialogueEnded = Net:FindFirstChild("RE/DialogueEnded")
                local RE_SearchItemPickedUp = Net:FindFirstChild("RE/SearchItemPickedUp")
                
                if not RE_DialogueEnded or not RE_SearchItemPickedUp then
                    Lexs("Dorian Quest Error: Required remotes not found!")
                    dorianRunning = false
                    return
                end
                
                Lexs("Dorian Quest: Starting...")
                
                -- Step 1: Start Dialogue
                pcall(function() RE_DialogueEnded:FireServer("Dorian", 1, 1) end)
                task.wait(1)
                
                -- Step 2: Collect Coral 33x
                if dorianRunning then
                    Lexs("Dorian Quest: Collecting 30 Coral...")
                    for i = 1, 33 do
                        if not dorianRunning then break end
                        pcall(function() RE_SearchItemPickedUp:FireServer("Coral") end)
                    end
                end
                
                task.wait(1)
                
                -- Step 3: Finish Dialogue
                if dorianRunning then
                    Lexs("Dorian Quest: Finishing quest...")
                    pcall(function() RE_DialogueEnded:FireServer("Dorian", 1, 2) end)
                end
                
                if dorianRunning then
                    Lexs("Dorian Quest: Completed!")
                end
                
                dorianRunning = false
            end)
        else
            if dorianThread then
                task.cancel(dorianThread)
                dorianThread = nil
            end
            dorianRunning = false
            Lexs("Dorian Quest: Stopped")
        end
    end
})

x12 = Tabs.Quest:AddSection("Auto Quest Hank (Pickaxe)")

local HankStatus = x12:AddParagraph({
    Title = "Hank Quest Status",
    Content = "Click toggle to start..."
})

local hankRunning = false
local hankThread = nil

local function HasHanksDiary()
    local r = ClientData
    if not r then return false end
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if not s or not i or not i.Items then return false end
    
    for _, it in ipairs(i.Items) do
        if it.Id == 20222 or (it.Name and string.find(it.Name, "Hank's Diary")) then
            return true
        end
    end
    return false
end

x12:AddToggle({
    Title = "Auto Complete Hank Quest",
    Description = "Claim Quest â†’ Fish Diary (Crystal Depths) â†’ Turn In",
    Default = false,
    Callback = function(s)
        hankRunning = s
        
        if s then
            hankThread = task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Net = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
                local RE_DialogueEnded = Net:WaitForChild("RE/DialogueEnded")
                local RE_Obtained = Net:FindFirstChild("RE/ObtainedNewFishNotification")
                
                -- Instant Fish Remotes
                local RFC = Net:WaitForChild("RF/ChargeFishingRod")
                local RFS = Net:WaitForChild("RF/RequestFishingMinigameStarted")
                local REF = Net:WaitForChild("RE/FishingCompleted")
                local RFK = Net:WaitForChild("RF/CancelFishingInputs")
                local RE_Equip = Net:WaitForChild("RE/EquipToolFromHotbar")

                -- Listen for Diary Catch
                local catchListener
                if RE_Obtained then
                    catchListener = RE_Obtained.OnClientEvent:Connect(function(uiData)
                        if uiData and (uiData.Name == "Hank's Diary" or string.find(tostring(uiData.Name), "Diary")) then
                            Lexs("Hank Quest: Diary caught!")
                            pcall(function()
                                HankStatus:SetContent("Diary caught! Stopping fishing...")
                            end)
                        end
                    end)
                end

                -- Equip Rod Initially
                Lexs("Hank Quest: Equipping rod...")
                pcall(function()
                    HankStatus:SetContent("Equipping Rod...")
                end)
                RE_Equip:FireServer(1)
                task.wait(0.5)

                -- Blatant V3 Logic Setup
                local CD, FD, KD = 0.45, 0.7, 0.3
                local function safe(f) task.spawn(function() pcall(f) end) end

                -- Equip/Unequip Remotes
                local RE_UnequipItem = Net:WaitForChild("RE/UnequipItem")
                local RE_EquipItem = Net:WaitForChild("RE/EquipItem")

                -- Helper: Unequip All
                local function UnequipAll()
                    local s, e = pcall(function() return ClientData:GetExpect("EquippedItems") end)
                    if s and e then
                        for _, u in ipairs(e) do
                            pcall(function() RE_UnequipItem:FireServer(u) end)
                            task.wait(0.05)
                        end
                    end
                end

                -- Helper: Get Diary UUID
                local function GetDiaryUUID()
                    local r = ClientData
                    if not r then return nil end
                    local s, i = pcall(function() return r:GetExpect("Inventory") end)
                    if s and i and i.Items then
                        for _, it in ipairs(i.Items) do
                            if tonumber(it.Id) == 20222 and it.UUID then
                                return it.UUID
                            end
                        end
                    end
                    return nil
                end

                while hankRunning do
                    -- 1. Check if we already have the Diary
                    if HasHanksDiary() then
                        Lexs("Hank Quest: Diary found! Preparing turn-in...")
                        pcall(function()
                            HankStatus:SetContent("Diary Found! Preparing Turn-in...")
                        end)
                        
                        -- Unequip All
                        UnequipAll()
                        task.wait(0.5)
                        
                        -- Equip Diary
                        local dUUID = GetDiaryUUID()
                        if dUUID then
                            Lexs("Hank Quest: Equipping diary...")
                            pcall(function()
                                HankStatus:SetContent("Equipping Diary...")
                            end)
                            pcall(function() RE_EquipItem:FireServer(dUUID, "Gears") end)
                            task.wait(0.5)
                        end
                        
                        -- Unequip Tool Hotbar (Stabilization)
                        local RE_UnequipHotbar = Net:FindFirstChild("RE/UnequipToolFromHotbar")
                        if RE_UnequipHotbar then
                            pcall(function() RE_UnequipHotbar:FireServer() end)
                            task.wait(0.5)
                        end
                        
                        -- Equip Slot 2
                        pcall(function() RE_Equip:FireServer(2) end)
                        task.wait(0.5)
                        
                        Lexs("Hank Quest: Turning in to Hank...")
                        pcall(function()
                            HankStatus:SetContent("Turning in to Hank...")
                        end)
                        RE_DialogueEnded:FireServer("Hank", 1, 3)
                        task.wait(0.5)
                        RE_DialogueEnded:FireServer("Hank", 1, 3)
                        
                        if catchListener then catchListener:Disconnect() end
                        Lexs("Hank Quest: Completed! Pickaxe received.")
                        pcall(function()
                            HankStatus:SetContent("Quest Completed! Pickaxe Received.")
                        end)
                        break
                    end
                    
                    -- Start Quest just in case
                    pcall(function() RE_DialogueEnded:FireServer("Hank", 1, 2) end)
                    
                    -- Teleport Check
                    local targetPos = CFrame.new(5682, -890, 15430)
                    local char = game.Players.LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        if (char.HumanoidRootPart.Position - targetPos.Position).Magnitude > 20 then
                            Lexs("Hank Quest: Teleporting to Crystal Depths...")
                            pcall(function()
                                HankStatus:SetContent("Teleporting to Crystal Depths...")
                            end)
                            char.HumanoidRootPart.CFrame = targetPos
                            task.wait(1)
                            RE_Equip:FireServer(1) -- Re-equip if teleported
                            task.wait(0.5)
                        end
                    end
                    
                    if not hankRunning then break end

                    -- Blatant V3 Cycle
                    pcall(function()
                        HankStatus:SetContent("Fishing (Blatant V3 Async)...")
                    end)
                    
                    local t = tick()
                    safe(function() RFC:InvokeServer({[1] = t}) end)
                    task.wait(CD)
                    local r = tick()
                    safe(function() RFS:InvokeServer(1, 0, r) end)
                    
                    local t2 = tick()
                    safe(function() RFC:InvokeServer({[1] = t2}) end)
                    task.wait(CD)
                    local r2 = tick()
                    safe(function() RFS:InvokeServer(1, 0, r2) end)
                    
                    task.wait(FD)
                    if not hankRunning then break end
                    
                    safe(function() REF:FireServer() end)
                    safe(function() REF:FireServer() end)
                    
                    task.wait(KD)
                    safe(function() RFK:InvokeServer() end)
                    task.wait(0.001)
                end
                
                if catchListener then catchListener:Disconnect() end
                hankRunning = false
                pcall(function()
                    HankStatus:SetContent("Stopped")
                end)
            end)
        else
            if hankThread then
                task.cancel(hankThread)
                hankThread = nil
            end
            hankRunning = false
            Lexs("Hank Quest: Stopped")
            pcall(function()
                HankStatus:SetContent("Stopped")
            end)
        end
    end
})

x12 = Tabs.Quest:AddSection("Auto Quest Archeologist")

local ArchStatus = x12:AddParagraph({
    Title = "Archaeologist Quest Status",
    Content = "Click toggle to start..."
})

local archRunning = false
local archThread = nil

local function IsArchQuestActive()
    local r = ClientData
    if not r then return false end
    local s, q = pcall(function() return r:GetExpect("ActiveQuests") end)
    if s and q then
        for _, v in pairs(q) do
            local n = tostring(v.Name or "")
            local d = tostring(v.Description or "")
            if string.find(n, "Leviathan's Scale") or string.find(d, "Leviathan's Scale") or v.NPC == "Archaeologist" then
                return true
            end
        end
    end
    return false
end

x12:AddToggle({
    Title = "Auto Archaeologist (Leviathan Scale)",
    Description = "Start Quest â†’ Farm Objectives (Magma/Ocean/Essence + 200 Fish)",
    Default = false,
    Callback = function(s)
        archRunning = s
        
        if s then
            archThread = task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Net = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
                local RE_DialogueEnded = Net:WaitForChild("RE/DialogueEnded")
                local RE_Obtained = Net:FindFirstChild("RE/ObtainedNewFishNotification")
                
                -- Instant Fish Remotes
                local RFC = Net:WaitForChild("RF/ChargeFishingRod")
                local RFS = Net:WaitForChild("RF/RequestFishingMinigameStarted")
                local REF = Net:WaitForChild("RE/FishingCompleted")
                local RFK = Net:WaitForChild("RF/CancelFishingInputs")
                local RE_Equip = Net:WaitForChild("RE/EquipToolFromHotbar")

                -- Listen for Quest Items
                local catchListener
                if RE_Obtained then
                    catchListener = RE_Obtained.OnClientEvent:Connect(function(uiData)
                        local n = tostring(uiData.Name)
                        if n == "Magma Core" or n == "Leviathan Essence" or n == "Ocean Core" then
                            Lexs("Archaeologist: Caught " .. n)
                            pcall(function()
                                ArchStatus:SetContent("Caught Quest Item: " .. n)
                            end)
                        end
                    end)
                end

                -- 1. Try Start Quest
                Lexs("Archaeologist: Starting quest...")
                pcall(function()
                    ArchStatus:SetContent("Starting Quest (Archaeologist)...")
                end)
                RE_DialogueEnded:FireServer("Archaeologist", 1, 3)
                
                -- Wait for Quest to Appear
                local questActive = false
                for i = 1, 10 do
                    if IsArchQuestActive() then
                        questActive = true
                        break
                    end
                    task.wait(0.5)
                end

                -- Validate Quest Started (Warning Only)
                if not questActive then
                    Lexs("Archaeologist: Warning - Quest not detected in list, but continuing...")
                    pcall(function()
                        ArchStatus:SetContent("Warning: Quest Status Unknown (Continuing...)")
                    end)
                end
                
                Lexs("Archaeologist: Quest active! Moving to farm spot...")
                pcall(function()
                    ArchStatus:SetContent("Quest Active! Moving to Farm Spot...")
                end)

                -- Equip Rod Initially
                RE_Equip:FireServer(1)
                task.wait(0.5)

                -- Blatant V3 Logic Setup
                local CD, FD, KD = 0.45, 0.7, 0.3
                local function safe(f) task.spawn(function() pcall(f) end) end

                -- Gate Remotes
                local RF_Consume = Net:WaitForChild("RF/ConsumeItem")
                local RE_ClaimRelic = Net:WaitForChild("RE/ClaimRelic")
                local RE_PlaceRelic = Net:WaitForChild("RE/PlaceLeviathanPressureItem")
                
                -- Detect Scale UUID
                local function GetLeviathanScaleUUID()
                    local r = ClientData
                    if not r then return nil end
                    local s, i = pcall(function() return r:GetExpect("Inventory") end)
                    if s and i and i.Items then
                        for _, it in ipairs(i.Items) do
                            if tonumber(it.Id) == 576 and it.UUID then return it.UUID end
                        end
                    end
                    return nil
                end
                
                -- Detect Relic UUID
                local function GetRelicUUID(n, id)
                    local s, i = pcall(function() return ClientData:GetExpect("Inventory") end)
                    if s and i and i.Items then
                        for _, it in ipairs(i.Items) do
                            if (it.Name == n or tonumber(it.Id) == id) and it.UUID then return it.UUID end
                        end
                    end
                    return nil
                end

                local startPos = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

                while archRunning do
                    -- Check Completion (Reward Obtained)
                    local scaleUUID = GetLeviathanScaleUUID()
                    if scaleUUID then
                        Lexs("Archaeologist: Leviathan Scale found! Starting gate sequence...")
                        pcall(function()
                            ArchStatus:SetContent("Leviathan Scale Found! Starting Gate Sequence...")
                        end)
                        
                        -- 1. Consume Scale
                        Lexs("Archaeologist: Consuming Leviathan Scale...")
                        pcall(function()
                            ArchStatus:SetContent("Consuming Leviathan Scale...")
                        end)
                        pcall(function() RF_Consume:InvokeServer(scaleUUID) end)
                        task.wait(1.5)
                        
                        -- 2. Claim Relics
                        Lexs("Archaeologist: Claiming relics...")
                        pcall(function()
                            ArchStatus:SetContent("Claiming Relics...")
                        end)
                        RE_ClaimRelic:FireServer("Sunken Eye Relic")
                        RE_ClaimRelic:FireServer("Burntflame Relic")
                        RE_ClaimRelic:FireServer("Blacktide Relic")
                        task.wait(2)
                        
                        -- 3. Teleport to Gate
                        Lexs("Archaeologist: Teleporting to gate...")
                        pcall(function()
                            ArchStatus:SetContent("Teleporting to Gate...")
                        end)
                        local gatePos = CFrame.new(3445, -288, 3402)
                        local char = game.Players.LocalPlayer.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            char.HumanoidRootPart.CFrame = gatePos
                        end
                        task.wait(1)
                        
                        -- 4. Place Relics
                        Lexs("Archaeologist: Placing relics...")
                        pcall(function()
                            ArchStatus:SetContent("Placing Relics...")
                        end)
                        local r1 = GetRelicUUID("Sunken Eye Relic", 578)
                        local r2 = GetRelicUUID("Burntflame Relic", 579)
                        local r3 = GetRelicUUID("Blacktide Relic", 577)
                        
                        if r1 then pcall(function() RE_PlaceRelic:FireServer(r1, 1) end) end
                        task.wait(0.2)
                        if r2 then pcall(function() RE_PlaceRelic:FireServer(r2, 2) end) end
                        task.wait(0.2)
                        if r3 then pcall(function() RE_PlaceRelic:FireServer(r3, 3) end) end
                        task.wait(1)
                        
                        -- 5. Wait for Door
                        Lexs("Archaeologist: Waiting for door to open...")
                        pcall(function()
                            ArchStatus:SetContent("Waiting for Door to Open...")
                        end)
                        local door = workspace:FindFirstChild("LeviathanEvent")
                        if door and door:FindFirstChild("Door") then
                            local lDoor = door.Door:FindFirstChild("Left") and door.Door.Left:FindFirstChild("L_Door")
                            for i = 1, 60 do
                                if not archRunning then break end
                                if not lDoor or lDoor.Transparency > 0.5 or not lDoor.CanCollide then
                                    Lexs("Archaeologist: Door open! Entering...")
                                    pcall(function()
                                        ArchStatus:SetContent("Door Open! Entering...")
                                    end)
                                    break
                                end
                                task.wait(1)
                            end
                        end
                        
                        -- 6. Enter
                        local enterPos = CFrame.new(3471, -282, 3470)
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            char.HumanoidRootPart.CFrame = enterPos
                        end
                        
                        -- 7. Monitor Event Logic
                        Lexs("Archaeologist: Monitoring Leviathan event...")
                        pcall(function()
                            ArchStatus:SetContent("Monitoring Leviathan Event...")
                        end)
                        while archRunning do
                            task.wait(2)
                            local d = workspace:FindFirstChild("LeviathanEvent")
                            local ld = d and d:FindFirstChild("Door") and d.Door:FindFirstChild("Left") and d.Door.Left:FindFirstChild("L_Door")
                            
                            -- If Door Closed or Event Gone
                            if not ld or ld.Transparency < 0.1 then
                                Lexs("Archaeologist: Event ended. Returning...")
                                pcall(function()
                                    ArchStatus:SetContent("Event Ended. Returning...")
                                end)
                                break
                            end
                        end
                        
                        -- Return to Start Position
                        if startPos and char and char:FindFirstChild("HumanoidRootPart") then
                            char.HumanoidRootPart.CFrame = startPos
                        end
                        
                        Lexs("Archaeologist: Quest completed!")
                        archRunning = false
                        break
                    end
                    
                    -- Teleport Check
                    local targetPos = CFrame.new(-645, 30, 113)
                    local char = game.Players.LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        if (char.HumanoidRootPart.Position - targetPos.Position).Magnitude > 10 then
                            Lexs("Archaeologist: Teleporting to farming spot...")
                            pcall(function()
                                ArchStatus:SetContent("Teleporting to Farming Spot...")
                            end)
                            char.HumanoidRootPart.CFrame = targetPos
                            task.wait(1)
                            RE_Equip:FireServer(1)
                            task.wait(0.5)
                        end
                    end
                    
                    if not archRunning then break end

                    -- Blatant V3 Cycle
                    pcall(function()
                        ArchStatus:SetContent("Farming Objectives (Blatant V3)...")
                    end)
                    
                    local t = tick()
                    safe(function() RFC:InvokeServer({[1] = t}) end)
                    task.wait(CD)
                    local r = tick()
                    safe(function() RFS:InvokeServer(1, 0, r) end)
                    
                    local t2 = tick()
                    safe(function() RFC:InvokeServer({[1] = t2}) end)
                    task.wait(CD)
                    local r2 = tick()
                    safe(function() RFS:InvokeServer(1, 0, r2) end)
                    
                    task.wait(FD)
                    if not archRunning then break end
                    
                    safe(function() REF:FireServer() end)
                    safe(function() REF:FireServer() end)
                    
                    task.wait(KD)
                    safe(function() RFK:InvokeServer() end)
                    task.wait(0.001)
                end
                
                if catchListener then catchListener:Disconnect() end
                archRunning = false
                pcall(function()
                    ArchStatus:SetContent("Stopped")
                end)
            end)
        else
            if archThread then
                task.cancel(archThread)
                archThread = nil
            end
            archRunning = false
            Lexs("Archaeologist: Stopped")
            pcall(function()
                ArchStatus:SetContent("Stopped")
            end)
        end
    end
})

x12 = Tabs.Quest:AddSection("Auto Lever")

local leverStatus = x12:AddParagraph({
    Title = "Lever Status",
    Content = "Status: Inactive - Waiting for activation..."
})

local AUTO_LEVER_THREAD = nil
local AUTO_LEVER_EQUIP_THREAD = nil
local LEVER_FARMING_MODE = false
local AUTO_LEVER_ACTIVE = false
local LEVER_INSTANT_DELAY = 1.7

local ARTIFACT_IDS = {
    ["Arrow Artifact"] = 265,
    ["Crescent Artifact"] = 266,
    ["Diamond Artifact"] = 267,
    ["Hourglass Diamond Artifact"] = 271
}

local function GetRemote(p, n, t)
    local c = game:GetService("ReplicatedStorage")
    for _, k in ipairs(p) do
        c = c:WaitForChild(k, t or 0.5)
        if not c then return nil end
    end
    return c:FindFirstChild(n)
end

local RPath = {"Packages", "_Index", "sleitnick_net@0.2.0", "net"}
local RE_EquipToolFromHotbar = GetRemote(RPath, "RE/EquipToolFromHotbar")
local RF_PlaceLeverItem = GetRemote(RPath, "RE/PlaceLeverItem")
local RE_UnequipItem = GetRemote(RPath, "RE/UnequipItem")
local RE_EquipItem = GetRemote(RPath, "RE/EquipItem")
local RF_ChargeFishingRod = GetRemote(RPath, "RF/ChargeFishingRod")
local RF_RequestFishingMinigameStarted = GetRemote(RPath, "RF/RequestFishingMinigameStarted")
local RE_FishingCompleted = GetRemote(RPath, "RE/FishingCompleted")
local RF_CancelFishingInputs = GetRemote(RPath, "RF/CancelFishingInputs")

local ArtifactData = {
    ["Hourglass Diamond Artifact"] = {
        ItemName = "Hourglass Diamond Artifact",
        LeverName = "Hourglass Diamond Lever",
        ChildReference = 6,
        CrystalPathSuffix = "Crystal",
        UnlockColor = Color3.fromRGB(255, 248, 49),
        FishingPos = {Pos = Vector3.new(1490.144, 3.312, -843.171), Look = Vector3.new(0.115, 0, 0.993)}
    },
    ["Diamond Artifact"] = {
        ItemName = "Diamond Artifact",
        LeverName = "Diamond Lever",
        ChildReference = "TempleLever",
        CrystalPathSuffix = "Crystal",
        UnlockColor = Color3.fromRGB(219, 38, 255),
        FishingPos = {Pos = Vector3.new(1844.159, 2.53, -288.755), Look = Vector3.new(0.981, 0, -0.193)}
    },
    ["Arrow Artifact"] = {
        ItemName = "Arrow Artifact",
        LeverName = "Arrow Lever",
        ChildReference = 5,
        CrystalPathSuffix = "Crystal",
        UnlockColor = Color3.fromRGB(255, 47, 47),
        FishingPos = {Pos = Vector3.new(874.365, 2.53, -358.484), Look = Vector3.new(-0.99, 0, 0.144)}
    },
    ["Crescent Artifact"] = {
        ItemName = "Crescent Artifact",
        LeverName = "Crescent Lever",
        ChildReference = 4,
        CrystalPathSuffix = "Crystal",
        UnlockColor = Color3.fromRGB(112, 255, 69),
        FishingPos = {Pos = Vector3.new(1401.07, 6.489, 116.738), Look = Vector3.new(-0.5, 0, 0.866)}
    }
}

local ArtifactOrder = {"Hourglass Diamond Artifact", "Diamond Artifact", "Arrow Artifact", "Crescent Artifact"}

local function TeleportToLookAt(p, l)
    local c = game.Players.LocalPlayer.Character
    local h = c and c:FindFirstChild("HumanoidRootPart")
    if h then
        h.CFrame = CFrame.new(p, p + l)
    end
end

local function IsLeverUnlocked(a)
    local J = workspace:FindFirstChild("JUNGLE INTERACTIONS")
    if not J then return false end
    
    local d = ArtifactData[a]
    if not d then return false end
    
    local f = nil
    if type(d.ChildReference) == "string" then
        f = J:FindFirstChild(d.ChildReference)
    end
    if not f and type(d.ChildReference) == "number" then
        local c = J:GetChildren()
        f = c[d.ChildReference]
    end
    if not f then return false end
    
    local cr = f:FindFirstChild(d.CrystalPathSuffix)
    if not cr or not cr:IsA("BasePart") then return false end
    
    local cC, tC = cr.Color, d.UnlockColor
    return math.abs(cC.R * 255 - tC.R * 255) < 1.1 and 
           math.abs(cC.G * 255 - tC.G * 255) < 1.1 and 
           math.abs(cC.B * 255 - tC.B * 255) < 1.1
end

local function HasArtifactItem(a)
    local r = ClientData
    if not r then return false end
    local s, i = pcall(function() return r:GetExpect("Inventory") end)
    if not s or not i or not i.Items then return false end
    
    local id = ARTIFACT_IDS[a]
    if not id then return false end
    
    for _, it in ipairs(i.Items) do
        if tonumber(it.Id) == id then return true end
    end
    return false
end

local function RunQuestInstantFish(d)
    if not (RE_EquipToolFromHotbar and RF_ChargeFishingRod and RF_RequestFishingMinigameStarted and RE_FishingCompleted and RF_CancelFishingInputs) then
        return
    end
    
    local ts = os.time() + os.clock()
    pcall(function() RF_ChargeFishingRod:InvokeServer(ts) end)
    pcall(function() RF_RequestFishingMinigameStarted:InvokeServer(-139.630452165, 0.99647927980797) end)
    task.wait(d and d > 0 and d or LEVER_INSTANT_DELAY)
    pcall(function() RE_FishingCompleted:FireServer() end)
    task.wait(0.3)
    pcall(function() RF_CancelFishingInputs:InvokeServer() end)
end

local function EquipBestRod()
    if RE_EquipToolFromHotbar then
        pcall(function() RE_EquipToolFromHotbar:FireServer(1) end)
    end
end

x12:AddSlider({
    Title = "Fishing Delay",
    Description = "Delay untuk farming lever (seconds)",
    Min = 0.5,
    Max = 4.0,
    Default = 1.7,
    Rounding = 1,
    Callback = function(v)
        LEVER_INSTANT_DELAY = tonumber(v) or 1.7
        Lexs("Lever: Fishing delay set to " .. tostring(LEVER_INSTANT_DELAY) .. "s")
    end
})

local function RunAutoLeverLoop()
    if AUTO_LEVER_THREAD then
        task.cancel(AUTO_LEVER_THREAD)
    end
    if AUTO_LEVER_EQUIP_THREAD then
        task.cancel(AUTO_LEVER_EQUIP_THREAD)
    end
    
    AUTO_LEVER_EQUIP_THREAD = task.spawn(function()
        local t = 0
        while AUTO_LEVER_ACTIVE do
            if LEVER_FARMING_MODE and RE_EquipToolFromHotbar then
                pcall(function() RE_EquipToolFromHotbar:FireServer(1) end)
                if t % 20 == 0 then
                    EquipBestRod()
                end
                t = t + 1
            end
            task.wait(0.5)
        end
    end)
    
    -- Main thread
    AUTO_LEVER_THREAD = task.spawn(function()
        local c = game.Players.LocalPlayer.Character
        local h = c and c:FindFirstChild("HumanoidRootPart")
        
        while AUTO_LEVER_ACTIVE do
            local all = true
            local target = nil
            local s = "Current Status:\n"
            
            for _, a in ipairs(ArtifactOrder) do
                local d = ArtifactData[a]
                if d then
                    local u = IsLeverUnlocked(a)
                    s = s .. d.LeverName .. ": " .. (u and "Done" or "Locked") .. "\n"
                    if not u and not target then
                        target = a
                    end
                    if not u then
                        all = false
                    end
                end
            end
            
            pcall(function()
                leverStatus:SetContent(s)
            end)
            
            if all then
                Lexs("Auto Lever: All levers unlocked!")
                pcall(function()
                    leverStatus:SetContent("ALL LEVERS UNLOCKED!\nAll temple levers have been unlocked!")
                end)
                break
            elseif target then
                local d = ArtifactData[target]
                
                if HasArtifactItem(target) then
                    LEVER_FARMING_MODE = false
                    Lexs("Auto Lever: Placing " .. d.ItemName)
                    pcall(function()
                        leverStatus:SetContent("Placing: " .. d.ItemName)
                    end)
                    
                    if h then
                        TeleportToLookAt(d.FishingPos.Pos, d.FishingPos.Look)
                        h.Anchored = true
                    end
                    task.wait(0.5)
                    
                    if RE_UnequipItem then
                        pcall(function() RE_UnequipItem:FireServer("all") end)
                    end
                    task.wait(0.2)
                    
                    if RF_PlaceLeverItem then
                        pcall(function() RF_PlaceLeverItem:FireServer(target) end)
                    end
                    task.wait(2)
                    
                    if h then
                        h.Anchored = false
                    end
                    task.wait(1)
                else
                    LEVER_FARMING_MODE = true
                    pcall(function()
                        leverStatus:SetContent("Farming: " .. d.ItemName)
                    end)
                    
                    if h and (h.Position - d.FishingPos.Pos).Magnitude > 10 then
                        TeleportToLookAt(d.FishingPos.Pos, d.FishingPos.Look)
                        task.wait(0.5)
                    else
                        RunQuestInstantFish(LEVER_INSTANT_DELAY)
                        task.wait(0.1)
                    end
                end
            end
            
            task.wait(0.1)
        end
        
        AUTO_LEVER_ACTIVE = false
        LEVER_FARMING_MODE = false
        if AUTO_LEVER_EQUIP_THREAD then
            task.cancel(AUTO_LEVER_EQUIP_THREAD)
            AUTO_LEVER_EQUIP_THREAD = nil
        end
        if RE_EquipToolFromHotbar then
            pcall(function() RE_EquipToolFromHotbar:FireServer(0) end)
        end
    end)
end

x12:AddToggle({
    Title = "Enable Auto Lever",
    Default = false,
    Callback = function(s)
        AUTO_LEVER_ACTIVE = s
        
        if s then
            Lexs("Auto Lever: Starting...")
            pcall(function()
                leverStatus:SetContent("Lever Status - ACTIVE\nStarting Auto Lever system...")
            end)
            RunAutoLeverLoop()
        else
            Lexs("Auto Lever: Stopped")
            pcall(function()
                leverStatus:SetContent("Status: Inactive\nToggle to enable Auto Lever")
            end)
            
            if AUTO_LEVER_THREAD then
                task.cancel(AUTO_LEVER_THREAD)
                AUTO_LEVER_THREAD = nil
            end
            if AUTO_LEVER_EQUIP_THREAD then
                task.cancel(AUTO_LEVER_EQUIP_THREAD)
                AUTO_LEVER_EQUIP_THREAD = nil
            end
            
            LEVER_FARMING_MODE = false
            
            local c = game.Players.LocalPlayer.Character
            local h = c and c:FindFirstChild("HumanoidRootPart")
            if h then
                h.Anchored = false
            end
            
            if RE_EquipToolFromHotbar then
                pcall(function() RE_EquipToolFromHotbar:FireServer(0) end)
            end
        end
    end
})

sett = Tabs.Settings:AddSection("Player In Game")

local Players = game:GetService("Players")
local Stats = game:GetService("Stats")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Player = Players.LocalPlayer
local PingStat = Stats.Network.ServerStatsItem["Data Ping"]

-- REMOTE IKAN
local FishRemote =
	ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"]
	.net["RE/ObtainedNewFishNotification"]

-- GUI
local Gui = Instance.new("ScreenGui")
Gui.Name = "PerformanceHUD"
Gui.Parent = CoreGui
Gui.ResetOnSpawn = false
Gui.DisplayOrder = 2147483647

local Frame = Instance.new("Frame", Gui)
Frame.Size = UDim2.fromOffset(520,48)
Frame.Position = UDim2.fromScale(0.5,0.05)
Frame.AnchorPoint = Vector2.new(0.5,0)
Frame.BackgroundColor3 = Color3.fromRGB(0,0,0)
Frame.BackgroundTransparency = 0.7
Frame.BorderSizePixel = 0
Frame.Visible = false
Instance.new("UICorner",Frame).CornerRadius = UDim.new(0,24)

local Stroke = Instance.new("UIStroke", Frame)
Stroke.Thickness = 3

local Gradient = Instance.new("UIGradient", Stroke)
Gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0,255,255)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(180,255,255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255,255,255))
}

local Icon = Instance.new("ImageLabel", Frame)
Icon.Size = UDim2.fromOffset(22,22)
Icon.Position = UDim2.fromOffset(14,13)
Icon.BackgroundTransparency = 1
Icon.Image = "rbxassetid://71947103252559"

local Text = Instance.new("TextLabel", Frame)
Text.Size = UDim2.new(1,-60,1,0)
Text.Position = UDim2.fromOffset(52,0)
Text.BackgroundTransparency = 1
Text.Font = Enum.Font.GothamBold
Text.TextSize = 14
Text.TextXAlignment = Enum.TextXAlignment.Left
Text.TextColor3 = Color3.fromRGB(230,230,230)

-- DRAG
local dragging, dragStart, startPos
Frame.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = i.Position
		startPos = Frame.Position
	end
end)

UIS.InputEnded:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)

UIS.InputChanged:Connect(function(i)
	if dragging and i.UserInputType == Enum.UserInputType.MouseMovement then
		local d = i.Position - dragStart
		Frame.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + d.X,
			startPos.Y.Scale,
			startPos.Y.Offset + d.Y
		)
	end
end)

-- LOGIC
local ON = false
local fpsSmooth = 60
local cpuMsSmooth = 16
local lastTick = os.clock()

-- NOTIFICATION IKAN
local fishNotifCount = 0
local FISH_TIMEOUT = 3 -- detik

FishRemote.OnClientEvent:Connect(function()
	fishNotifCount += 1

	task.delay(FISH_TIMEOUT, function()
		fishNotifCount = math.max(0, fishNotifCount - 1)
	end)
end)

RunService.RenderStepped:Connect(function()
	if not ON then return end

	local now = os.clock()
	local dt = now - lastTick
	lastTick = now

	local fps = 1 / math.max(dt, 1/300)
	fpsSmooth += (fps - fpsSmooth) * 0.12

	local cpuMs = dt * 1000
	cpuMsSmooth += (cpuMs - cpuMsSmooth) * 0.2

	Text.Text = string.format(
		"PING: %d ms | FPS: %d | CPU: %.1f ms | NOTIF: %d",
		math.floor(PingStat:GetValue()),
		math.floor(fpsSmooth + 0.5),
		cpuMsSmooth,
		fishNotifCount
	)
end)

sett:AddToggle({
	Title = "Ping/Notification Display",
	Default = false,
	Callback = function(v)
		ON = v
		Frame.Visible = v
	end
})

local P = game:GetService("Players").LocalPlayer
local C = P.Character or P.CharacterAdded:Wait()
local O = C:WaitForChild("HumanoidRootPart"):WaitForChild("Overhead")
local H = O.Content.Header
local L = O.LevelContainer.Label

local D = {h = H.Text, l = L.Text, ch = H.Text, cl = L.Text, on = false}

sett:AddInput({
    Title = "Hide Name",
    Placeholder = "Input Name",
    Default = D.h,
    Callback = function(v)
        D.ch = v
        if D.on then H.Text = v end
    end
})

sett:AddInput({
    Title = "Hide Level",
    Placeholder = "Input Level",
    Default = D.l,
    Callback = function(v)
        D.cl = v
        if D.on then L.Text = v end
    end
})

sett:AddToggle({
    Title = "Hide Name & Level (Custom)",
    Default = false,
    Callback = function(v)
        D.on = v
        if v then
            H.Text = D.ch
            L.Text = D.cl
        else
            H.Text = D.h
            L.Text = D.l
        end
    end
})

local P = game:GetService("Players").LocalPlayer
local HN, HL = "discord.gg/lexshub", "Lv. ???"
local S = {on = false, ui = nil}

local function setup(c)
    local o = c:WaitForChild("HumanoidRootPart"):WaitForChild("Overhead")
    local h = o.Content.Header
    local l = o.LevelContainer.Label
    return {h = h, l = l, dh = h.Text, dl = l.Text}
end

S.ui = setup(P.Character or P.CharacterAdded:Wait())

P.CharacterAdded:Connect(function(c)
    task.wait(0.2)
    S.ui = setup(c)
    if S.on then
        S.ui.h.Text = HN
        S.ui.l.Text = HL
    end
end)

sett:AddToggle({
    Title = "Hide Name & Level (Default)",
    Default = false,
    Callback = function(v)
        S.on = v
        if not S.ui then return end
        if v then
            S.ui.h.Text = HN
            S.ui.l.Text = HL
        else
            S.ui.h.Text = S.ui.dh
            S.ui.l.Text = S.ui.dl
        end
    end
})

local P = game:GetService("Players").LocalPlayer
local Z = {P.CameraMaxZoomDistance, P.CameraMinZoomDistance}

sett:AddToggle({
    Title = "Infinite Zoom",
    Default = false,
    Callback=function(s)
        if s then
            P.CameraMaxZoomDistance=math.huge
            P.CameraMinZoomDistance=.5
        else
            P.CameraMaxZoomDistance=Z[1] or 128
            P.CameraMinZoomDistance=Z[2] or .5
        end
    end
})

local P = game:GetService("Players")
local T = game:GetService("TeleportService")
local LP = P.LocalPlayer
local PID = game.PlaceId
local ON = true

local BL = {
    [75974130]=1,[40397833]=1,[187190686]=1,[33372493]=1,[889918695]=1,
    [33679472]=1,[30944240]=1,[25050357]=1,[8462585751]=1,[8811129148]=1,
    [192821024]=1,[4509801805]=1,[124505170]=1,[108397209]=1
}

sett:AddToggle({
    Title = "Anti Staff",
    Default = true,
    Callback=function(s)
        ON=s
    end
})

local function hop()
    task.wait(6)
    local d = game.HttpService:JSONDecode(
        game:HttpGet("https://games.roblox.com/v1/games/"..PID.."/servers/Public?sortOrder=Asc&limit=100")
    ).data
    for _,v in ipairs(d) do
        if v.playing < v.maxPlayers and v.id ~= game.JobId then
            T:TeleportToPlaceInstance(PID, v.id, LP)
            break
        end
    end
end

P.PlayerAdded:Connect(function(plr)
    if ON and plr~=LP and BL[plr.UserId] then
        Lexs(plr.Name.." has joined, serverhop in 6 seconds...")
        hop()
    end
end)

task.spawn(function()
    while task.wait(2) do
        if ON then
            for _,plr in ipairs(P:GetPlayers()) do
                if plr~=LP and BL[plr.UserId] then
                    Lexs(plr.Name.." has joined, serverhop in 6 seconds...")
                    hop()
                    break
                end
            end
        end
    end
end)

sett = Tabs.Settings:AddSection("Graphic In Game")

local isBoostActive = false
local originalLightingValues = {}

local function ToggleFPSBoost(enabled)
	isBoostActive = enabled
	local Lighting = game:GetService("Lighting")
	local Terrain = workspace:FindFirstChildOfClass("Terrain")

	if enabled then
		if not next(originalLightingValues) then
			originalLightingValues.GlobalShadows = Lighting.GlobalShadows
			originalLightingValues.FogEnd = Lighting.FogEnd
			originalLightingValues.Brightness = Lighting.Brightness
			originalLightingValues.ClockTime = Lighting.ClockTime
			originalLightingValues.Ambient = Lighting.Ambient
			originalLightingValues.OutdoorAmbient = Lighting.OutdoorAmbient
		end

		pcall(function()
			for _, v in pairs(workspace:GetDescendants()) do
				if v:IsA("ParticleEmitter")
				or v:IsA("Trail")
				or v:IsA("Smoke")
				or v:IsA("Fire")
				or v:IsA("Explosion") then
					v.Enabled = false
				elseif v:IsA("Beam") or v:IsA("Light") then
					v.Enabled = false
				elseif v:IsA("Decal") or v:IsA("Texture") then
					v.Transparency = 1
				end
			end
		end)

		pcall(function()
			for _, effect in pairs(Lighting:GetChildren()) do
				if effect:IsA("PostEffect") then
					effect.Enabled = false
				end
			end
			Lighting.GlobalShadows = false
			Lighting.FogEnd = 9e9
			Lighting.Brightness = 3
			Lighting.ClockTime = 14
			Lighting.Ambient = Color3.new(0,0,0)
			Lighting.OutdoorAmbient = Color3.new(0,0,0)
		end)

		if Terrain then
			pcall(function()
				Terrain.WaterWaveSize = 0
				Terrain.WaterWaveSpeed = 0
				Terrain.WaterReflectance = 0
				Terrain.WaterTransparency = 1
				Terrain.Decoration = false
			end)
		end

		pcall(function()
			settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
			settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level01
			settings().Rendering.TextureQuality = Enum.TextureQuality.Low
		end)

		if type(setfpscap) == "function" then
			pcall(function() setfpscap(100) end)
		end

		if type(collectgarbage) == "function" then
			collectgarbage("collect")
		end

		Lexs("FPS Ultra Boost ON")

	else
		pcall(function()
			if originalLightingValues.GlobalShadows ~= nil then
				Lighting.GlobalShadows = originalLightingValues.GlobalShadows
				Lighting.FogEnd = originalLightingValues.FogEnd
				Lighting.Brightness = originalLightingValues.Brightness
				Lighting.ClockTime = originalLightingValues.ClockTime
				Lighting.Ambient = originalLightingValues.Ambient
				Lighting.OutdoorAmbient = originalLightingValues.OutdoorAmbient
			end

			settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic

			for _, effect in pairs(Lighting:GetChildren()) do
				if effect:IsA("PostEffect") then
					effect.Enabled = true
				end
			end
		end)

		if type(setfpscap) == "function" then
			pcall(function() setfpscap(60) end)
		end
	end
end

sett:AddToggle({
	Title = "FPS Ultra Boost",
	Default = false,
	Callback = function(state)
		ToggleFPSBoost(state)
	end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

local PopupConn
local RemoteConn

sett:AddToggle({
    Title = "Remove Fish Notification Pop-up",
    Default = false,
    Callback = function(state)

        local function getPopup()
            local gui = PlayerGui:FindFirstChild("Small Notification")
            if not gui then return end
            local display = gui:FindFirstChild("Display")
            if not display then return end
            return display:FindFirstChild("NewFrame")
        end

        local RemoteEvent =
            ReplicatedStorage
            :WaitForChild("Packages")
            :WaitForChild("_Index")
            :WaitForChild("sleitnick_net@0.2.0")
            :WaitForChild("net")
            :WaitForChild("RE/ObtainedNewFishNotification")

        if state then
            local frame = getPopup()
            if frame then
                frame.Visible = false
                frame:Destroy()
            end

            PopupConn = PlayerGui.DescendantAdded:Connect(function(v)
                if v.Name == "NewFrame" then
                    task.wait()
                    v.Visible = false
                    v:Destroy()
                end
            end)

            RemoteConn = RemoteEvent.OnClientEvent:Connect(function()
                local f = getPopup()
                if f then
                    f.Visible = false
                    f:Destroy()
                end
            end)
            Lexs("Fish Pop-up Disabled")
        else
            if PopupConn then PopupConn:Disconnect() PopupConn = nil end
            if RemoteConn then RemoteConn:Disconnect() RemoteConn = nil end
        end
    end
})

local R = game:GetService("RunService")
local P = game:GetService("Players").LocalPlayer
local G

sett:AddToggle({
    Title = "Disable 3D Rendering",
    Default = false,
    Callback = function(s)
        pcall(function() R:Set3dRenderingEnabled(not s) end)
        if s then
            G = Instance.new("ScreenGui")
            G.IgnoreGuiInset = true
            G.ResetOnSpawn = false
            G.Parent = P.PlayerGui

            Instance.new("Frame", G).Size = UDim2.fromScale(1,1)
            G.Frame.BackgroundColor3 = Color3.new(1,1,1)
            G.Frame.BorderSizePixel = 0
        elseif G then
            G:Destroy()
            G = nil
        end
    end
})

local W = workspace
local L = game:GetService("Lighting")

local S = {on = false, cache = {}}

local VFX = {
    ParticleEmitter = true, Beam = true, Trail = true, Smoke = true,
    Fire = true, Sparkles = true, Explosion = true,
    PointLight = true, SpotLight = true, SurfaceLight = true, Highlight = true
}

local LE = {
    BloomEffect = true, SunRaysEffect = true, ColorCorrectionEffect = true,
    DepthOfFieldEffect = true, Atmosphere = true
}

local function disable()
    for _, o in ipairs(W:GetDescendants()) do
        if VFX[o.ClassName] and o.Enabled == true then
            S.cache[o] = true
            o.Enabled = false
        end
    end

    for _, o in ipairs(L:GetChildren()) do
        if LE[o.ClassName] and o.Enabled ~= nil then
            S.cache[o] = true
            o.Enabled = false
        end
    end
end

local function restore()
    for o in pairs(S.cache) do
        if o and o.Parent and o.Enabled ~= nil then
            o.Enabled = true
        end
    end
    table.clear(S.cache)
end

-- listener cuma sekali (ANTI LEAK)
W.DescendantAdded:Connect(function(o)
    if S.on and VFX[o.ClassName] and o.Enabled ~= nil then
        task.defer(function() o.Enabled = false end)
    end
end)

L.DescendantAdded:Connect(function(o)
    if S.on and LE[o.ClassName] and o.Enabled ~= nil then
        task.defer(function() o.Enabled = false end)
    end
end)

sett:AddToggle({
    Title = "Hide All VFX",
    Default = false,
    Callback = function(state)
        S.on = state
        if state then
            disable()
        else
            restore()
        end
    end
})

local VFX = require(game:GetService("ReplicatedStorage").Controllers.VFXController)

-- simpan fungsi asli (cukup sekali)
local ORI = {
    H = VFX.Handle,
    P = VFX.RenderAtPoint,
    I = VFX.RenderInstance
}

sett:AddToggle({
    Title = "Remove Skin Effect",
    Default = false,
    Callback = function(state)
        if state then
            -- disable VFX
            VFX.Handle = function() end
            VFX.RenderAtPoint = function() end
            VFX.RenderInstance = function() end

            local f = workspace:FindFirstChild("CosmeticFolder")
            if f then
                pcall(f.ClearAllChildren, f)
            end
            Lexs("Skin Effect Disabled")
        else
            -- restore VFX
            VFX.Handle = ORI.H
            VFX.RenderAtPoint = ORI.P
            VFX.RenderInstance = ORI.I
        end
    end
})

sett = Tabs.Settings:AddSection("Server")

sett:AddButton({
    Title = "Rejoin",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer

TeleportService:Teleport(game.PlaceId, player)

    end
})

Players = game:GetService("Players")
TeleportService = game:GetService("TeleportService")

Player = Players.LocalPlayer
PlaceId = game.PlaceId

sett:AddButton({
	Title = "Server Hop",
	Callback = function()
		TeleportService:Teleport(PlaceId, Player)
	end
})

web = Tabs.Webhook:AddSection("Webhook Discord")

local b = ""
local c = "https://discord.com/api/webhooks/1463851568414724247/pxVOEsCQIJywOlDC2KZak-UAdHVWklkRs-rhtN6eLfows59wKEtl94GuwRRVwtAAHYvy"
local d = false
local e = true
local f = {"Legendary", "Mythic", "SECRET"}
local g = {"SECRET", "TROPHY", "COLLECTIBLE", "DEV"}
local h = game:GetService("HttpService")
local i = game:GetService("ReplicatedStorage")
local j = game:GetService("Players")
local k = j.LocalPlayer
local l = require(i.Shared.ItemUtility)
local m = require(i.Packages.Replion)
local n = {}
local o = {}
local p = {}
local function q(r)
local s = {
[1] = "Common",
[2] = "Uncommon",
[3] = "Rare",
[4] = "Epic",
[5] = "Legendary",
[6] = "Mythic",
[7] = "SECRET"
}
return s[r] or "Common"
end
local function t()
local u = i:FindFirstChild("Items")
if not u then
return 0
end
local v = 0
for w, x in pairs(u:GetDescendants()) do
if x:IsA("ModuleScript") then
local y, z =
pcall(
function()
return require(x)
end
)
if y and z then
local A = z.Data or z
if A and type(A) == "table" and A.Id and A.Name then
v = v + 1
n[A.Id] = A.Name
o[A.Id] = A.Tier or 1
if z.SellPrice then
p[A.Id] = z.SellPrice
elseif A.SellPrice then
p[A.Id] = A.SellPrice
else
p[A.Id] = 0
end
end
end
end
end
return v
end
task.spawn(t)
local B = {}
local C = 0
local D = 0
local E = 0.5
local function F(G)
if not G or type(G) ~= "string" or #G < 1 then
return "Unknown"
end
if #G <= 3 then
return G
end
local H = G:sub(1, 3)
local I = #G - 3
local J = string.rep("*", I)
return H .. J
end
local function K(L)
L = tonumber(L)
if not L then
return "0"
end
L = math.floor(L)
local M = tostring(L):reverse():gsub("%d%d%d", "%1."):reverse()
return M:gsub("^%.", "")
end
local function N()
local y, O =
pcall(
function()
if m and m.Client then
local P = m.Client:WaitReplion("Data", 2)
if P then
local Q = P:Get("Coins")
if Q then
return Q
end
local R = P:Get("Currency")
if R and type(R) == "table" then
return R.Coins or R.Gold or R.Money or 0
end
end
end
local S = k:FindFirstChild("leaderstats")
if S then
local T =
S:FindFirstChild("C$") or S:FindFirstChild("Coins") or S:FindFirstChild("Gold") or
S:FindFirstChild("Money")
if T then
return T.Value
end
end
return 0
end
)
if y then
return O or 0
else
return 0
end
end
local function U(V)
local W = V:upper()
if W == "SECRET" then
return 16711935
end
if W == "MYTHIC" then
return 16753920
end
if W == "LEGENDARY" then
return 16776960
end
if W == "EPIC" then
return 8388736
end
if W == "RARE" then
return 255
end
if W == "UNCOMMON" then
return 65280
end
return 16777215
end
local function X(Y)
local Z = {
["Common"] = "<a:jj:1306049474707329075>",
["Uncommon"] = "<a:jj:1306049474707329075>",
["Rare"] = "<a:jj:1306049474707329075>",
["Epic"] = "<a:jj:1306049474707329075>",
["Legendary"] = "<a:jj:1306049474707329075>",
["Mythic"] = "<a:jj:1306049474707329075>",
["SECRET"] = "<a:jj:1306049474707329075>"
}
return Z[Y] or "ðŸŽ£"
end
local function _(a0)
if not a0 or a0 == 0 then
return "https://tr.rbxcdn.com/53eb9b170bea9855c45c9356fb33c070/420/420/Image/Png"
end
if B[a0] then
return B[a0]
end
local a1 =
string.format(
"https://thumbnails.roblox.com/v1/assets?assetIds=%d&size=420x420&format=Png&isCircular=false",
a0
)
local y, a2 =
pcall(
function()
return game:HttpGet(a1, true)
end
)
if y then
local a3, A = pcall(h.JSONDecode, h, a2)
if a3 and A and A.data and A.data[1] and A.data[1].imageUrl then
local a4 = A.data[1].imageUrl
B[a0] = a4
return a4
end
end
return "https://tr.rbxcdn.com/53eb9b170bea9855c45c9356fb33c070/420/420/Image/Png"
end
local function a5(a1, a6)
if a1 == "" or not a1:find("https://discord.com/api/webhooks/") then
return false
end
local a7 = tick()
if a7 - C < E then
return false
end
C = a7
local y, a8 =
pcall(
function()
local a9 = {
username = "Lexs Hub | Community",
avatar_url = "https://cdn.discordapp.com/attachments/1427988930103476225/1463860113470259277/lexshubicon.png?ex=69735d78&is=69720bf8&hm=441d158d01fc67dcfb697d8a8e47b5d005fb17997eaaabd581ca4e533b9992c1&",
embeds = {a6}
}
local aa = h:JSONEncode(a9)
local ab
if syn and syn.request then
ab = syn.request
elseif http and http.request then
ab = http.request
elseif request then
ab = request
elseif fluxus and fluxus.request then
ab = fluxus.request
elseif http_request then
ab = http_request
else
return false
end
if not ab then
return false
end
local a2 = ab({Url = a1, Method = "POST", Headers = {["Content-Type"] = "application/json"}, Body = aa})
if a2 then
local ac = a2.StatusCode or a2.status or a2.Code
if ac then
if ac == 204 or ac == 200 then
return true
else
return false
end
else
if type(a2) == "string" then
return true
end
return false
end
else
return false
end
end
)
if not y then
return false
end
return true
end
local function ad(a1, a6)
if a1 == "" or not a1:find("https://discord.com/api/webhooks/") then
return false
end
local a7 = tick()
if a7 - D < E then
return false
end
D = a7
local y, a8 =
pcall(
function()
local a9 = {
username = "Lexs Hub | Community",
avatar_url = "https://cdn.discordapp.com/attachments/1427988930103476225/1463860113470259277/lexshubicon.png?ex=69735d78&is=69720bf8&hm=441d158d01fc67dcfb697d8a8e47b5d005fb17997eaaabd581ca4e533b9992c1&",
embeds = {a6}
}
local aa = h:JSONEncode(a9)
local ab
if syn and syn.request then
ab = syn.request
elseif http and http.request then
ab = http.request
elseif request then
ab = request
elseif fluxus and fluxus.request then
ab = fluxus.request
elseif http_request then
ab = http_request
else
return false
end
if not ab then
return false
end
local a2 = ab({Url = a1, Method = "POST", Headers = {["Content-Type"] = "application/json"}, Body = aa})
if a2 then
local ac = a2.StatusCode or a2.status or a2.Code
if ac then
if ac == 204 or ac == 200 then
return true
else
return false
end
else
if type(a2) == "string" then
return true
end
return false
end
else
return false
end
end
)
if not y then
return false
end
return true
end
local function ae(af, ag, z, ah)
if not af then
return
end
local ai = n[af] or "Unknown Fish"
local r = o[af] or 1
local aj = q(r)
local ak
local y, a8 =
pcall(
function()
ak = l:GetItemData(af)
end
)
local al = ai
local am = aj
local an = p[af] or 0
if y and ak then
if ak.Data and ak.Data.Name then
al = ak.Data.Name
end
if ak.SellPrice then
an = ak.SellPrice
end
end
if z and z.InventoryItem and z.InventoryItem.Metadata then
local ao = z.InventoryItem.Metadata.Rarity
if ao and ao ~= "" then
am = ao
end
end
am = string.upper(am)
if am == "SECRET" or am == "7" then
am = "SECRET"
elseif am == "MYTHIC" or am == "6" then
am = "Mythic"
elseif am == "LEGENDARY" or am == "5" then
am = "Legendary"
elseif am == "EPIC" or am == "4" then
am = "Epic"
elseif am == "RARE" or am == "3" then
am = "Rare"
elseif am == "UNCOMMON" or am == "2" then
am = "Uncommon"
else
am = "Common"
end
local ap = ag and ag.Weight or 0
local aq = ag and ag.SellMultiplier or 1
local ar = math.floor(an * aq)
local as = "Normal"
if ag then
if ag.Shiny then
as = "âœ¨ Shiny"
elseif ag.Albino then
as = "âšª"
elseif ag.Golden then
as = "ðŸŒŸ"
elseif ag.Rainbow then
as = "ðŸŒˆ"
elseif ag.Crystal then
as = "ðŸ’Ž"
elseif ag.VariantId then
as = "ðŸ§¬" .. tostring(ag.VariantId)
end
end
local a0 = 0
if y and ak and ak.Data then
if ak.Data.Icon then
a0 = tonumber(string.match(tostring(ak.Data.Icon), "%d+")) or 0
elseif ak.Data.ImageId then
a0 = tonumber(ak.Data.ImageId) or 0
end
end
local at = _(a0)
local Q = N()
local au = k.DisplayName or k.Name
if d and b ~= "" then
local av = false
for w, aw in ipairs(f) do
if string.upper(aw) == string.upper(am) then
av = true
break
end
end
if av then
local ax = X(am)
local ay = {
title = ax .. " Private Catch: " .. al,
color = U(am),
fields = {
{name = "**Rarity**", value = am, inline = true},
{name = "**Weight**", value = string.format("%.2f kg", ap), inline = true},
{name = "**Mutation**", value = as, inline = true},
{name = "**Value**", value = "$" .. K(ar), inline = true},
{name = "**Coins**", value = "$" .. K(Q), inline = true},
{name = "**Player**", value = "||" .. au .. "||", inline = true}
},
thumbnail = {url = at},
footer = {text = "Lexs Hub | Private Log"},
timestamp = DateTime.now():ToIsoDate()
}
a5(b, ay)
end
end
if e and c ~= "" then
local az = false
for w, aw in ipairs(g) do
if string.upper(aw) == string.upper(am) then
az = true
break
end
end
if az then
local aA = F(au)
local ax = X(am)
local aB = {
title = ax .. " Global Catch Alert!",
description = "**Someone just caught a " .. al .. "!**",
color = U(am),
fields = {
{name = "<a:arrow:1306059259615903826> Fish", value = al, inline = true},
{name = "<a:arrow:1306059259615903826> Rarity", value = am, inline = true},
{name = "<a:arrow:1306059259615903826> Weight", value = string.format("%.2f kg", ap), inline = true},
{name = "<a:arrow:1306059259615903826> Mutation", value = as, inline = true},
{name = "<a:arrow:1306059259615903826> Value", value = "$" .. K(ar), inline = true},
{name = "<a:arrow:1306059259615903826> Fisherman", value = aA, inline = true}
},
thumbnail = {url = at},
footer = {text = "Lexs Hub | Global Tracker"},
timestamp = DateTime.now():ToIsoDate()
}
ad(c, aB)
end
end
end

local function convertDropdownTable(fluentTable)
    local array = {}
    if not fluentTable then return array end
    
    for value, isSelected in pairs(fluentTable) do
        if isSelected then
            table.insert(array, value)
        end
    end
    return array
end

local aC = web:AddInput({
    Title = "Private Webhook URL",
    Placeholder = "https://discord.com/api/webhooks/...",
    Callback = function(v)
        if v and v ~= "" then
            b = v
        end
    end
})

local aE = web:AddDropdown({
    Title = "Private Notify Tiers",
    Options = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "SECRET"},
    Multi = true,
    Value = {"SECRET"},
    Callback = function(selectedTable)
        f = selectedTable
    end
})

local aF = web:AddToggle({
    Title = "Enable Private Webhook",
    Default = false,
    Callback = function(aG)
        d = aG
    end
})

web:AddButton({
    Title = "Test Private Webhook",
    Callback = function()
        if not d or b == "" then
            Lexs("Private Webhook Is Not Enabled Or Url Empty.")
            return
        end
        local Q = N()
        local aI = {
            title = "ðŸŽ£ Test Notification",
            description = "Webhook is working correctly!",
            color = 65535,
            fields = {
                {name = "<a:arrow:1306059259615903826> User", value = k.DisplayName or k.Name, inline = true},
                {name = "<a:arrow:1306059259615903826> Coins", value = "$" .. K(Q), inline = true},
                {name = "<a:arrow:1306059259615903826> Status", value = "Connected", inline = true},
                {
                    name = "<a:arrow:1306059259615903826> Test Tier",
                    value = "All tiers should work now",
                    inline = true
                }
            },
            footer = {text = "Lexs Hub | Test Message"},
            timestamp = DateTime.now():ToIsoDate()
        }
        local y = a5(b, aI)
        if y then
            Lexs("Success! Test message sent to your webhook.")
        else
           Lexs("Failed! Check Discord Webhook Url.")
        end
    end
})

t()
local function aJ()
local function aK()
local aL = i:FindFirstChild("Packages")
if aL then
local aM = aL:FindFirstChild("_Index")
if aM then
local aN = aM:FindFirstChild("sleitnick_net@0.2.0")
if aN then
local aO = aN:FindFirstChild("net")
if aO then
local aP =
aO:FindFirstChild("RE/ObtainedNewFishNotification") or aO:FindFirstChild("RE/FishCaught") or
aO:FindFirstChild("RE/CatchFish")
if aP then
return aP
end
end
end
local aQ = aM:FindFirstChild("cemstone_net@0.2.1")
if aQ then
local aO = aQ:FindFirstChild("net")
if aO then
local aP =
aO:FindFirstChild("RE/ObtainedNewFishNotification") or aO:FindFirstChild("RE/FishCaught")
if aP then
return aP
end
end
end
end
end
local aR = i:FindFirstChild("Events")
if aR then
local aP =
aR:FindFirstChild("FishCaught") or aR:FindFirstChild("ObtainedNewFish") or
aR:FindFirstChild("CatchFish")
if aP then
return aP
end
end
return nil
end
local aS = aK()
if aS then
if _G.WebhookConnection then
_G.WebhookConnection:Disconnect()
_G.WebhookConnection = nil
end
_G.WebhookConnection =
aS.OnClientEvent:Connect(
function(...)
local aT = {...}
if #aT >= 2 then
local af, ag, z
for aU, aV in ipairs(aT) do
if type(aV) == "table" then
if aV.Weight then
ag = aV
elseif aV.InventoryItem then
z = aV
end
elseif type(aV) == "number" then
af = aV
end
end
if not af then
for w, aV in ipairs(aT) do
if type(aV) == "number" and aV > 0 then
af = aV
break
end
end
end
if af then
pcall(
function()
ae(af, ag or {}, z or {}, true)
end
)
end
end
end
)
end
end
aJ()
task.delay(
3,
function()
aJ()
end
)
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(
function()
task.wait(2)
aJ()
end
)

if Window then
    Lexs("Thank For Using LexsHub Premium!")
end
